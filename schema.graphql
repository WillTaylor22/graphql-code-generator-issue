"""The root query type which gives access points into the data universe."""
type Query implements Node {
  """
  Exposes the root query type nested one level down. This is helpful for Relay 1
  which can only query top level fields if they are in a particular form.
  """
  query: Query!

  """
  The root query type must be a `Node` to work well with Relay 1 mutations. This just resolves to `query`.
  """
  nodeId: ID!

  """Fetches an object given its globally unique `ID`."""
  node(
    """The globally unique `ID`."""
    nodeId: ID!
  ): Node

  """Reads and enables pagination through a set of `AccountUser`."""
  allAccountUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountUserCondition
  ): AccountUsersConnection

  """Reads and enables pagination through a set of `Account`."""
  allAccounts(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition
  ): AccountsConnection

  """
  Reads and enables pagination through a set of `ActiveStorageAttachment`.
  """
  allActiveStorageAttachments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActiveStorageAttachment`."""
    orderBy: [ActiveStorageAttachmentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActiveStorageAttachmentCondition
  ): ActiveStorageAttachmentsConnection

  """Reads and enables pagination through a set of `ActiveStorageBlob`."""
  allActiveStorageBlobs(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActiveStorageBlob`."""
    orderBy: [ActiveStorageBlobsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActiveStorageBlobCondition
  ): ActiveStorageBlobsConnection

  """
  Reads and enables pagination through a set of `ActiveStorageVariantRecord`.
  """
  allActiveStorageVariantRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActiveStorageVariantRecord`."""
    orderBy: [ActiveStorageVariantRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActiveStorageVariantRecordCondition
  ): ActiveStorageVariantRecordsConnection

  """Reads and enables pagination through a set of `ArInternalMetadatum`."""
  allArInternalMetadata(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ArInternalMetadatum`."""
    orderBy: [ArInternalMetadataOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ArInternalMetadatumCondition
  ): ArInternalMetadataConnection

  """Reads and enables pagination through a set of `CommentThread`."""
  allCommentThreads(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CommentThread`."""
    orderBy: [CommentThreadsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentThreadCondition
  ): CommentThreadsConnection

  """Reads and enables pagination through a set of `Comment`."""
  allComments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentCondition
  ): CommentsConnection

  """Reads and enables pagination through a set of `ContactUser`."""
  allContactUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContactUserCondition
  ): ContactUsersConnection

  """Reads and enables pagination through a set of `ConversationUser`."""
  allConversationUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConversationUserCondition
  ): ConversationUsersConnection

  """Reads and enables pagination through a set of `Conversation`."""
  allConversations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Conversation`."""
    orderBy: [ConversationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConversationCondition
  ): ConversationsConnection

  """Reads and enables pagination through a set of `DocumentUser`."""
  allDocumentUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentUserCondition
  ): DocumentUsersConnection

  """Reads and enables pagination through a set of `Document`."""
  allDocuments(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection

  """Reads and enables pagination through a set of `Email`."""
  allEmails(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection

  """Reads and enables pagination through a set of `FigmaPage`."""
  allFigmaPages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `FigmaPage`."""
    orderBy: [FigmaPagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: FigmaPageCondition
  ): FigmaPagesConnection

  """Reads and enables pagination through a set of `Invoice`."""
  allInvoices(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvoiceCondition
  ): InvoicesConnection

  """Reads and enables pagination through a set of `Item`."""
  allItems(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Item`."""
    orderBy: [ItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ItemCondition
  ): ItemsConnection

  """Reads and enables pagination through a set of `Lane`."""
  allLanes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LaneCondition
  ): LanesConnection

  """Reads and enables pagination through a set of `Mention`."""
  allMentions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Mention`."""
    orderBy: [MentionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MentionCondition
  ): MentionsConnection

  """Reads and enables pagination through a set of `MessageFile`."""
  allMessageFiles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MessageFile`."""
    orderBy: [MessageFilesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageFileCondition
  ): MessageFilesConnection

  """Reads and enables pagination through a set of `MessageUser`."""
  allMessageUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageUserCondition
  ): MessageUsersConnection

  """Reads and enables pagination through a set of `Message`."""
  allMessages(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageCondition
  ): MessagesConnection

  """Reads and enables pagination through a set of `Notification`."""
  allNotifications(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition
  ): NotificationsConnection

  """Reads and enables pagination through a set of `PaymentErrorRecord`."""
  allPaymentErrorRecords(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PaymentErrorRecord`."""
    orderBy: [PaymentErrorRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentErrorRecordCondition
  ): PaymentErrorRecordsConnection

  """Reads and enables pagination through a set of `PaymentMethod`."""
  allPaymentMethods(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PaymentMethod`."""
    orderBy: [PaymentMethodsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentMethodCondition
  ): PaymentMethodsConnection

  """Reads and enables pagination through a set of `Plan`."""
  allPlans(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Plan`."""
    orderBy: [PlansOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PlanCondition
  ): PlansConnection

  """Reads and enables pagination through a set of `ProjectUser`."""
  allProjectUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectUserCondition
  ): ProjectUsersConnection

  """Reads and enables pagination through a set of `Project`."""
  allProjects(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
  ): ProjectsConnection

  """Reads and enables pagination through a set of `Reaction`."""
  allReactions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReactionCondition
  ): ReactionsConnection

  """Reads and enables pagination through a set of `Recording`."""
  allRecordings(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecordingCondition
  ): RecordingsConnection

  """Reads and enables pagination through a set of `SchemaMigration`."""
  allSchemaMigrations(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SchemaMigrationCondition
  ): SchemaMigrationsConnection

  """Reads and enables pagination through a set of `Sequence`."""
  allSequences(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SequenceCondition
  ): SequencesConnection

  """Reads and enables pagination through a set of `SiteFile`."""
  allSiteFiles(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SiteFile`."""
    orderBy: [SiteFilesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SiteFileCondition
  ): SiteFilesConnection

  """Reads and enables pagination through a set of `StorageFolder`."""
  allStorageFolders(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StorageFolderCondition
  ): StorageFoldersConnection

  """Reads and enables pagination through a set of `Stroke`."""
  allStrokes(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Stroke`."""
    orderBy: [StrokesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StrokeCondition
  ): StrokesConnection

  """Reads and enables pagination through a set of `Subscription`."""
  allSubscriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionCondition
  ): SubscriptionsConnection

  """Reads and enables pagination through a set of `Suggestion`."""
  allSuggestions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Suggestion`."""
    orderBy: [SuggestionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SuggestionCondition
  ): SuggestionsConnection

  """Reads and enables pagination through a set of `Todo`."""
  allTodos(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Todo`."""
    orderBy: [TodosOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TodoCondition
  ): TodosConnection

  """Reads and enables pagination through a set of `Transcription`."""
  allTranscriptions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transcription`."""
    orderBy: [TranscriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TranscriptionCondition
  ): TranscriptionsConnection

  """Reads and enables pagination through a set of `User`."""
  allUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition
  ): UsersConnection

  """Reads and enables pagination through a set of `Version`."""
  allVersions(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VersionCondition
  ): VersionsConnection

  """Reads and enables pagination through a set of `WorkspaceUser`."""
  allWorkspaceUsers(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceUserCondition
  ): WorkspaceUsersConnection

  """Reads and enables pagination through a set of `Workspace`."""
  allWorkspaces(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceCondition
  ): WorkspacesConnection
  accountUserById(id: UUID!): AccountUser
  accountById(id: UUID!): Account
  activeStorageAttachmentById(id: BigInt!): ActiveStorageAttachment
  activeStorageBlobById(id: BigInt!): ActiveStorageBlob
  activeStorageVariantRecordById(id: BigInt!): ActiveStorageVariantRecord
  arInternalMetadatumByKey(key: String!): ArInternalMetadatum
  commentThreadById(id: UUID!): CommentThread
  commentById(id: UUID!): Comment
  contactUserById(id: BigInt!): ContactUser
  conversationUserById(id: BigInt!): ConversationUser
  conversationById(id: UUID!): Conversation
  documentUserById(id: UUID!): DocumentUser
  documentById(id: UUID!): Document
  emailById(id: BigInt!): Email
  figmaPageById(id: UUID!): FigmaPage
  invoiceById(id: BigInt!): Invoice
  itemById(id: UUID!): Item
  laneById(id: UUID!): Lane
  mentionById(id: UUID!): Mention
  messageFileById(id: UUID!): MessageFile
  messageUserById(id: BigInt!): MessageUser
  messageById(id: UUID!): Message
  notificationById(id: UUID!): Notification
  paymentErrorRecordById(id: BigInt!): PaymentErrorRecord
  paymentMethodById(id: UUID!): PaymentMethod
  planById(id: UUID!): Plan
  projectUserById(id: UUID!): ProjectUser
  projectById(id: UUID!): Project
  reactionById(id: UUID!): Reaction
  recordingById(id: UUID!): Recording
  schemaMigrationByVersion(version: String!): SchemaMigration
  sequenceById(id: BigInt!): Sequence
  siteFileById(id: UUID!): SiteFile
  storageFolderById(id: UUID!): StorageFolder
  strokeById(id: BigInt!): Stroke
  subscriptionById(id: UUID!): Subscription
  suggestionById(id: BigInt!): Suggestion
  todoById(id: UUID!): Todo
  transcriptionById(id: BigInt!): Transcription
  userById(id: UUID!): User
  versionById(id: UUID!): Version
  workspaceUserById(id: UUID!): WorkspaceUser
  workspaceById(id: UUID!): Workspace

  """Reads a single `AccountUser` using its globally unique `ID`."""
  accountUser(
    """
    The globally unique `ID` to be used in selecting a single `AccountUser`.
    """
    nodeId: ID!
  ): AccountUser

  """Reads a single `Account` using its globally unique `ID`."""
  account(
    """The globally unique `ID` to be used in selecting a single `Account`."""
    nodeId: ID!
  ): Account

  """
  Reads a single `ActiveStorageAttachment` using its globally unique `ID`.
  """
  activeStorageAttachment(
    """
    The globally unique `ID` to be used in selecting a single `ActiveStorageAttachment`.
    """
    nodeId: ID!
  ): ActiveStorageAttachment

  """Reads a single `ActiveStorageBlob` using its globally unique `ID`."""
  activeStorageBlob(
    """
    The globally unique `ID` to be used in selecting a single `ActiveStorageBlob`.
    """
    nodeId: ID!
  ): ActiveStorageBlob

  """
  Reads a single `ActiveStorageVariantRecord` using its globally unique `ID`.
  """
  activeStorageVariantRecord(
    """
    The globally unique `ID` to be used in selecting a single `ActiveStorageVariantRecord`.
    """
    nodeId: ID!
  ): ActiveStorageVariantRecord

  """Reads a single `ArInternalMetadatum` using its globally unique `ID`."""
  arInternalMetadatum(
    """
    The globally unique `ID` to be used in selecting a single `ArInternalMetadatum`.
    """
    nodeId: ID!
  ): ArInternalMetadatum

  """Reads a single `CommentThread` using its globally unique `ID`."""
  commentThread(
    """
    The globally unique `ID` to be used in selecting a single `CommentThread`.
    """
    nodeId: ID!
  ): CommentThread

  """Reads a single `Comment` using its globally unique `ID`."""
  comment(
    """The globally unique `ID` to be used in selecting a single `Comment`."""
    nodeId: ID!
  ): Comment

  """Reads a single `ContactUser` using its globally unique `ID`."""
  contactUser(
    """
    The globally unique `ID` to be used in selecting a single `ContactUser`.
    """
    nodeId: ID!
  ): ContactUser

  """Reads a single `ConversationUser` using its globally unique `ID`."""
  conversationUser(
    """
    The globally unique `ID` to be used in selecting a single `ConversationUser`.
    """
    nodeId: ID!
  ): ConversationUser

  """Reads a single `Conversation` using its globally unique `ID`."""
  conversation(
    """
    The globally unique `ID` to be used in selecting a single `Conversation`.
    """
    nodeId: ID!
  ): Conversation

  """Reads a single `DocumentUser` using its globally unique `ID`."""
  documentUser(
    """
    The globally unique `ID` to be used in selecting a single `DocumentUser`.
    """
    nodeId: ID!
  ): DocumentUser

  """Reads a single `Document` using its globally unique `ID`."""
  document(
    """The globally unique `ID` to be used in selecting a single `Document`."""
    nodeId: ID!
  ): Document

  """Reads a single `Email` using its globally unique `ID`."""
  email(
    """The globally unique `ID` to be used in selecting a single `Email`."""
    nodeId: ID!
  ): Email

  """Reads a single `FigmaPage` using its globally unique `ID`."""
  figmaPage(
    """The globally unique `ID` to be used in selecting a single `FigmaPage`."""
    nodeId: ID!
  ): FigmaPage

  """Reads a single `Invoice` using its globally unique `ID`."""
  invoice(
    """The globally unique `ID` to be used in selecting a single `Invoice`."""
    nodeId: ID!
  ): Invoice

  """Reads a single `Item` using its globally unique `ID`."""
  item(
    """The globally unique `ID` to be used in selecting a single `Item`."""
    nodeId: ID!
  ): Item

  """Reads a single `Lane` using its globally unique `ID`."""
  lane(
    """The globally unique `ID` to be used in selecting a single `Lane`."""
    nodeId: ID!
  ): Lane

  """Reads a single `Mention` using its globally unique `ID`."""
  mention(
    """The globally unique `ID` to be used in selecting a single `Mention`."""
    nodeId: ID!
  ): Mention

  """Reads a single `MessageFile` using its globally unique `ID`."""
  messageFile(
    """
    The globally unique `ID` to be used in selecting a single `MessageFile`.
    """
    nodeId: ID!
  ): MessageFile

  """Reads a single `MessageUser` using its globally unique `ID`."""
  messageUser(
    """
    The globally unique `ID` to be used in selecting a single `MessageUser`.
    """
    nodeId: ID!
  ): MessageUser

  """Reads a single `Message` using its globally unique `ID`."""
  message(
    """The globally unique `ID` to be used in selecting a single `Message`."""
    nodeId: ID!
  ): Message

  """Reads a single `Notification` using its globally unique `ID`."""
  notification(
    """
    The globally unique `ID` to be used in selecting a single `Notification`.
    """
    nodeId: ID!
  ): Notification

  """Reads a single `PaymentErrorRecord` using its globally unique `ID`."""
  paymentErrorRecord(
    """
    The globally unique `ID` to be used in selecting a single `PaymentErrorRecord`.
    """
    nodeId: ID!
  ): PaymentErrorRecord

  """Reads a single `PaymentMethod` using its globally unique `ID`."""
  paymentMethod(
    """
    The globally unique `ID` to be used in selecting a single `PaymentMethod`.
    """
    nodeId: ID!
  ): PaymentMethod

  """Reads a single `Plan` using its globally unique `ID`."""
  plan(
    """The globally unique `ID` to be used in selecting a single `Plan`."""
    nodeId: ID!
  ): Plan

  """Reads a single `ProjectUser` using its globally unique `ID`."""
  projectUser(
    """
    The globally unique `ID` to be used in selecting a single `ProjectUser`.
    """
    nodeId: ID!
  ): ProjectUser

  """Reads a single `Project` using its globally unique `ID`."""
  project(
    """The globally unique `ID` to be used in selecting a single `Project`."""
    nodeId: ID!
  ): Project

  """Reads a single `Reaction` using its globally unique `ID`."""
  reaction(
    """The globally unique `ID` to be used in selecting a single `Reaction`."""
    nodeId: ID!
  ): Reaction

  """Reads a single `Recording` using its globally unique `ID`."""
  recording(
    """The globally unique `ID` to be used in selecting a single `Recording`."""
    nodeId: ID!
  ): Recording

  """Reads a single `SchemaMigration` using its globally unique `ID`."""
  schemaMigration(
    """
    The globally unique `ID` to be used in selecting a single `SchemaMigration`.
    """
    nodeId: ID!
  ): SchemaMigration

  """Reads a single `Sequence` using its globally unique `ID`."""
  sequence(
    """The globally unique `ID` to be used in selecting a single `Sequence`."""
    nodeId: ID!
  ): Sequence

  """Reads a single `SiteFile` using its globally unique `ID`."""
  siteFile(
    """The globally unique `ID` to be used in selecting a single `SiteFile`."""
    nodeId: ID!
  ): SiteFile

  """Reads a single `StorageFolder` using its globally unique `ID`."""
  storageFolder(
    """
    The globally unique `ID` to be used in selecting a single `StorageFolder`.
    """
    nodeId: ID!
  ): StorageFolder

  """Reads a single `Stroke` using its globally unique `ID`."""
  stroke(
    """The globally unique `ID` to be used in selecting a single `Stroke`."""
    nodeId: ID!
  ): Stroke

  """Reads a single `Subscription` using its globally unique `ID`."""
  subscription(
    """
    The globally unique `ID` to be used in selecting a single `Subscription`.
    """
    nodeId: ID!
  ): Subscription

  """Reads a single `Suggestion` using its globally unique `ID`."""
  suggestion(
    """
    The globally unique `ID` to be used in selecting a single `Suggestion`.
    """
    nodeId: ID!
  ): Suggestion

  """Reads a single `Todo` using its globally unique `ID`."""
  todo(
    """The globally unique `ID` to be used in selecting a single `Todo`."""
    nodeId: ID!
  ): Todo

  """Reads a single `Transcription` using its globally unique `ID`."""
  transcription(
    """
    The globally unique `ID` to be used in selecting a single `Transcription`.
    """
    nodeId: ID!
  ): Transcription

  """Reads a single `User` using its globally unique `ID`."""
  user(
    """The globally unique `ID` to be used in selecting a single `User`."""
    nodeId: ID!
  ): User

  """Reads a single `Version` using its globally unique `ID`."""
  version(
    """The globally unique `ID` to be used in selecting a single `Version`."""
    nodeId: ID!
  ): Version

  """Reads a single `WorkspaceUser` using its globally unique `ID`."""
  workspaceUser(
    """
    The globally unique `ID` to be used in selecting a single `WorkspaceUser`.
    """
    nodeId: ID!
  ): WorkspaceUser

  """Reads a single `Workspace` using its globally unique `ID`."""
  workspace(
    """The globally unique `ID` to be used in selecting a single `Workspace`."""
    nodeId: ID!
  ): Workspace
}

"""An object with a globally unique `ID`."""
interface Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
}

"""A connection to a list of `AccountUser` values."""
type AccountUsersConnection {
  """A list of `AccountUser` objects."""
  nodes: [AccountUser]!

  """
  A list of edges which contains the `AccountUser` and cursor to aid in pagination.
  """
  edges: [AccountUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `AccountUser` you could get from the connection."""
  totalCount: Int!
}

type AccountUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int!
  accountId: UUID!
  viewer: Boolean!
  id: UUID!
  position: Int!
  showRecent: Boolean!
  showShared: Boolean!
  specificProjectsOnly: Boolean!
  lastViewedSharedAt: Datetime
  lastViewedRecentAt: Datetime
  lastViewedFeedAt: Datetime
  slackEmail: String
  slackId: String
  sharedNotificationCount: Int!

  """Reads a single `User` that is related to this `AccountUser`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `AccountUser`."""
  accountByAccountId: Account
}

"""
A universally unique identifier as defined by [RFC 4122](https://tools.ietf.org/html/rfc4122).
"""
scalar UUID

"""
A point in time as described by the [ISO
8601](https://en.wikipedia.org/wiki/ISO_8601) standard. May or may not include a timezone.
"""
scalar Datetime

type User implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  email: String!
  firstName: String
  lastName: String
  id: UUID!
  photoProcessingStatus: Int!
  photoProcessingError: String
  notificationCount: Int!
  currentAccountId: UUID
  showSidebar: Boolean!
  emailOnProductUpdates: Boolean!
  emailOnMessages: Boolean!
  emailOnFeedback: Boolean!
  emailLimitToDaily: Boolean!
  enableDesktopNotifications: Boolean
  color: String
  emailOnMentionsAndAssignments: Boolean!
  hasUsedTrial: Boolean!
  currentMic: String
  currentCamera: String
  showTextToolbars: Boolean!
  emojiSkinTone: String
  penColor: String!
  penSize: Float!
  photoTemporary: String
  hasDesktopApp: Boolean
  offerDesktopApp: Boolean!
  conversationsOpen: Boolean!
  currentRoute: String

  """Reads a single `Account` that is related to this `User`."""
  accountByCurrentAccountId: Account

  """Reads and enables pagination through a set of `Document`."""
  documentsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!

  """Reads and enables pagination through a set of `Sequence`."""
  sequencesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SequenceCondition
  ): SequencesConnection!

  """Reads and enables pagination through a set of `Sequence`."""
  sequencesBySenderId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SequenceCondition
  ): SequencesConnection!

  """Reads and enables pagination through a set of `Recording`."""
  recordingsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecordingCondition
  ): RecordingsConnection!

  """Reads and enables pagination through a set of `Version`."""
  versionsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VersionCondition
  ): VersionsConnection!

  """Reads and enables pagination through a set of `Notification`."""
  notificationsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition
  ): NotificationsConnection!

  """Reads and enables pagination through a set of `Notification`."""
  notificationsByOriginatorId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition
  ): NotificationsConnection!

  """Reads and enables pagination through a set of `Account`."""
  accountsByOwnerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition
  ): AccountsConnection!

  """Reads and enables pagination through a set of `AccountUser`."""
  accountUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountUserCondition
  ): AccountUsersConnection!

  """Reads and enables pagination through a set of `WorkspaceUser`."""
  workspaceUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceUserCondition
  ): WorkspaceUsersConnection!

  """Reads and enables pagination through a set of `DocumentUser`."""
  documentUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentUserCondition
  ): DocumentUsersConnection!

  """Reads and enables pagination through a set of `DocumentUser`."""
  documentUsersByAssignerId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentUserCondition
  ): DocumentUsersConnection!

  """Reads and enables pagination through a set of `Message`."""
  messagesByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageCondition
  ): MessagesConnection!

  """Reads and enables pagination through a set of `ContactUser`."""
  contactUsersByContactId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContactUserCondition
  ): ContactUsersConnection!

  """Reads and enables pagination through a set of `ContactUser`."""
  contactUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ContactUserCondition
  ): ContactUsersConnection!

  """Reads and enables pagination through a set of `MessageUser`."""
  messageUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageUserCondition
  ): MessageUsersConnection!

  """Reads and enables pagination through a set of `ProjectUser`."""
  projectUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectUserCondition
  ): ProjectUsersConnection!

  """Reads and enables pagination through a set of `Mention`."""
  mentionsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Mention`."""
    orderBy: [MentionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MentionCondition
  ): MentionsConnection!

  """Reads and enables pagination through a set of `Reaction`."""
  reactionsByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReactionCondition
  ): ReactionsConnection!

  """Reads and enables pagination through a set of `ConversationUser`."""
  conversationUsersByUserId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConversationUserCondition
  ): ConversationUsersConnection!
}

type Account implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String
  createdAt: Datetime!
  updatedAt: Datetime!
  ownerId: UUID!
  id: UUID!
  stripeId: String
  photoProcessingStatus: Int!
  photoProcessingError: String
  demo: Boolean!
  hasUsedTrial: Boolean!
  currentSubscriptionId: UUID
  currentPaymentMethodId: UUID
  offerDesktopNotifications: Boolean!
  maxVersions: Int!
  remainingVersions: Int!
  maxInvites: Int!
  remainingInvites: Int!
  maxTeamInvites: Int!
  remainingTeamInvites: Int!
  inviteToken: UUID!
  slackAccessToken: String
  slackIdentifier: String
  slackTeamName: String
  hasClients: Boolean!

  """Reads a single `User` that is related to this `Account`."""
  userByOwnerId: User

  """Reads a single `Subscription` that is related to this `Account`."""
  subscriptionByCurrentSubscriptionId: Subscription

  """Reads a single `PaymentMethod` that is related to this `Account`."""
  paymentMethodByCurrentPaymentMethodId: PaymentMethod

  """Reads and enables pagination through a set of `User`."""
  usersByCurrentAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: UserCondition
  ): UsersConnection!

  """Reads and enables pagination through a set of `Document`."""
  documentsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!

  """Reads and enables pagination through a set of `Invoice`."""
  invoicesByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvoiceCondition
  ): InvoicesConnection!

  """Reads and enables pagination through a set of `Email`."""
  emailsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `Notification`."""
  notificationsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition
  ): NotificationsConnection!

  """Reads and enables pagination through a set of `AccountUser`."""
  accountUsersByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountUserCondition
  ): AccountUsersConnection!

  """Reads and enables pagination through a set of `PaymentMethod`."""
  paymentMethodsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `PaymentMethod`."""
    orderBy: [PaymentMethodsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: PaymentMethodCondition
  ): PaymentMethodsConnection!

  """Reads and enables pagination through a set of `Lane`."""
  lanesByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LaneCondition
  ): LanesConnection!

  """Reads and enables pagination through a set of `Subscription`."""
  subscriptionsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionCondition
  ): SubscriptionsConnection!

  """Reads and enables pagination through a set of `Project`."""
  projectsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectCondition
  ): ProjectsConnection!

  """Reads and enables pagination through a set of `ProjectUser`."""
  projectUsersByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectUserCondition
  ): ProjectUsersConnection!

  """Reads and enables pagination through a set of `Conversation`."""
  conversationsByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Conversation`."""
    orderBy: [ConversationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConversationCondition
  ): ConversationsConnection!

  """Reads and enables pagination through a set of `StorageFolder`."""
  storageFoldersByAccountId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StorageFolderCondition
  ): StorageFoldersConnection!
}

type Subscription implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  accountId: UUID!
  planId: UUID!
  stripeId: String
  status: Int!
  startAt: Datetime!
  trialStartAt: Datetime
  renewAt: Datetime
  endAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  items: JSON

  """Reads a single `Account` that is related to this `Subscription`."""
  accountByAccountId: Account

  """Reads a single `Plan` that is related to this `Subscription`."""
  planByPlanId: Plan

  """Reads and enables pagination through a set of `Invoice`."""
  invoicesBySubscriptionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: InvoiceCondition
  ): InvoicesConnection!

  """Reads and enables pagination through a set of `Account`."""
  accountsByCurrentSubscriptionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition
  ): AccountsConnection!
}

"""
A JavaScript object encoded in the JSON format as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON

type Plan implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String!
  slug: String!
  period: String!
  priceCents: Int!
  stripeId: String!
  trialLength: Int!
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID!
  perSeatStripeId: String
  seatsIncluded: Int
  perSeatPriceCents: Int

  """Reads and enables pagination through a set of `Subscription`."""
  subscriptionsByPlanId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SubscriptionCondition
  ): SubscriptionsConnection!
}

"""A connection to a list of `Subscription` values."""
type SubscriptionsConnection {
  """A list of `Subscription` objects."""
  nodes: [Subscription]!

  """
  A list of edges which contains the `Subscription` and cursor to aid in pagination.
  """
  edges: [SubscriptionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Subscription` you could get from the connection."""
  totalCount: Int!
}

"""A `Subscription` edge in the connection."""
type SubscriptionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Subscription` at the end of the edge."""
  node: Subscription
}

"""A location in a connection that can be used for resuming pagination."""
scalar Cursor

"""Information about pagination in a connection."""
type PageInfo {
  """When paginating forwards, are there more items?"""
  hasNextPage: Boolean!

  """When paginating backwards, are there more items?"""
  hasPreviousPage: Boolean!

  """When paginating backwards, the cursor to continue."""
  startCursor: Cursor

  """When paginating forwards, the cursor to continue."""
  endCursor: Cursor
}

"""Methods to use when ordering `Subscription`."""
enum SubscriptionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  PLAN_ID_ASC
  PLAN_ID_DESC
  STRIPE_ID_ASC
  STRIPE_ID_DESC
  STATUS_ASC
  STATUS_DESC
  START_AT_ASC
  START_AT_DESC
  TRIAL_START_AT_ASC
  TRIAL_START_AT_DESC
  RENEW_AT_ASC
  RENEW_AT_DESC
  END_AT_ASC
  END_AT_DESC
  CANCELLED_AT_ASC
  CANCELLED_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ITEMS_ASC
  ITEMS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Subscription` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SubscriptionCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `planId` field."""
  planId: UUID

  """Checks for equality with the object’s `stripeId` field."""
  stripeId: String

  """Checks for equality with the object’s `status` field."""
  status: Int

  """Checks for equality with the object’s `startAt` field."""
  startAt: Datetime

  """Checks for equality with the object’s `trialStartAt` field."""
  trialStartAt: Datetime

  """Checks for equality with the object’s `renewAt` field."""
  renewAt: Datetime

  """Checks for equality with the object’s `endAt` field."""
  endAt: Datetime

  """Checks for equality with the object’s `cancelledAt` field."""
  cancelledAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `items` field."""
  items: JSON
}

"""A connection to a list of `Invoice` values."""
type InvoicesConnection {
  """A list of `Invoice` objects."""
  nodes: [Invoice]!

  """
  A list of edges which contains the `Invoice` and cursor to aid in pagination.
  """
  edges: [InvoicesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Invoice` you could get from the connection."""
  totalCount: Int!
}

type Invoice implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  accountId: UUID!
  lineItems: JSON!
  priceCents: Int!
  currency: String!
  paymentMethodId: UUID
  subscriptionId: UUID
  stripeId: String!
  status: Int!
  pdfLink: String
  planName: String

  """Reads a single `Account` that is related to this `Invoice`."""
  accountByAccountId: Account

  """Reads a single `Subscription` that is related to this `Invoice`."""
  subscriptionBySubscriptionId: Subscription
}

"""
A signed eight-byte integer. The upper big integer values are greater than the
max value for a JavaScript number. Therefore all big integers will be output as
strings and not numbers.
"""
scalar BigInt

"""A `Invoice` edge in the connection."""
type InvoicesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Invoice` at the end of the edge."""
  node: Invoice
}

"""Methods to use when ordering `Invoice`."""
enum InvoicesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  LINE_ITEMS_ASC
  LINE_ITEMS_DESC
  PRICE_CENTS_ASC
  PRICE_CENTS_DESC
  CURRENCY_ASC
  CURRENCY_DESC
  PAYMENT_METHOD_ID_ASC
  PAYMENT_METHOD_ID_DESC
  SUBSCRIPTION_ID_ASC
  SUBSCRIPTION_ID_DESC
  STRIPE_ID_ASC
  STRIPE_ID_DESC
  STATUS_ASC
  STATUS_DESC
  PDF_LINK_ASC
  PDF_LINK_DESC
  PLAN_NAME_ASC
  PLAN_NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Invoice` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input InvoiceCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `lineItems` field."""
  lineItems: JSON

  """Checks for equality with the object’s `priceCents` field."""
  priceCents: Int

  """Checks for equality with the object’s `currency` field."""
  currency: String

  """Checks for equality with the object’s `paymentMethodId` field."""
  paymentMethodId: UUID

  """Checks for equality with the object’s `subscriptionId` field."""
  subscriptionId: UUID

  """Checks for equality with the object’s `stripeId` field."""
  stripeId: String

  """Checks for equality with the object’s `status` field."""
  status: Int

  """Checks for equality with the object’s `pdfLink` field."""
  pdfLink: String

  """Checks for equality with the object’s `planName` field."""
  planName: String
}

"""A connection to a list of `Account` values."""
type AccountsConnection {
  """A list of `Account` objects."""
  nodes: [Account]!

  """
  A list of edges which contains the `Account` and cursor to aid in pagination.
  """
  edges: [AccountsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Account` you could get from the connection."""
  totalCount: Int!
}

"""A `Account` edge in the connection."""
type AccountsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Account` at the end of the edge."""
  node: Account
}

"""Methods to use when ordering `Account`."""
enum AccountsOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  OWNER_ID_ASC
  OWNER_ID_DESC
  ID_ASC
  ID_DESC
  STRIPE_ID_ASC
  STRIPE_ID_DESC
  PHOTO_PROCESSING_STATUS_ASC
  PHOTO_PROCESSING_STATUS_DESC
  PHOTO_PROCESSING_ERROR_ASC
  PHOTO_PROCESSING_ERROR_DESC
  DEMO_ASC
  DEMO_DESC
  HAS_USED_TRIAL_ASC
  HAS_USED_TRIAL_DESC
  CURRENT_SUBSCRIPTION_ID_ASC
  CURRENT_SUBSCRIPTION_ID_DESC
  CURRENT_PAYMENT_METHOD_ID_ASC
  CURRENT_PAYMENT_METHOD_ID_DESC
  OFFER_DESKTOP_NOTIFICATIONS_ASC
  OFFER_DESKTOP_NOTIFICATIONS_DESC
  MAX_VERSIONS_ASC
  MAX_VERSIONS_DESC
  REMAINING_VERSIONS_ASC
  REMAINING_VERSIONS_DESC
  MAX_INVITES_ASC
  MAX_INVITES_DESC
  REMAINING_INVITES_ASC
  REMAINING_INVITES_DESC
  MAX_TEAM_INVITES_ASC
  MAX_TEAM_INVITES_DESC
  REMAINING_TEAM_INVITES_ASC
  REMAINING_TEAM_INVITES_DESC
  INVITE_TOKEN_ASC
  INVITE_TOKEN_DESC
  SLACK_ACCESS_TOKEN_ASC
  SLACK_ACCESS_TOKEN_DESC
  SLACK_IDENTIFIER_ASC
  SLACK_IDENTIFIER_DESC
  SLACK_TEAM_NAME_ASC
  SLACK_TEAM_NAME_DESC
  HAS_CLIENTS_ASC
  HAS_CLIENTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Account` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input AccountCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `ownerId` field."""
  ownerId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `stripeId` field."""
  stripeId: String

  """Checks for equality with the object’s `photoProcessingStatus` field."""
  photoProcessingStatus: Int

  """Checks for equality with the object’s `photoProcessingError` field."""
  photoProcessingError: String

  """Checks for equality with the object’s `demo` field."""
  demo: Boolean

  """Checks for equality with the object’s `hasUsedTrial` field."""
  hasUsedTrial: Boolean

  """Checks for equality with the object’s `currentSubscriptionId` field."""
  currentSubscriptionId: UUID

  """Checks for equality with the object’s `currentPaymentMethodId` field."""
  currentPaymentMethodId: UUID

  """
  Checks for equality with the object’s `offerDesktopNotifications` field.
  """
  offerDesktopNotifications: Boolean

  """Checks for equality with the object’s `maxVersions` field."""
  maxVersions: Int

  """Checks for equality with the object’s `remainingVersions` field."""
  remainingVersions: Int

  """Checks for equality with the object’s `maxInvites` field."""
  maxInvites: Int

  """Checks for equality with the object’s `remainingInvites` field."""
  remainingInvites: Int

  """Checks for equality with the object’s `maxTeamInvites` field."""
  maxTeamInvites: Int

  """Checks for equality with the object’s `remainingTeamInvites` field."""
  remainingTeamInvites: Int

  """Checks for equality with the object’s `inviteToken` field."""
  inviteToken: UUID

  """Checks for equality with the object’s `slackAccessToken` field."""
  slackAccessToken: String

  """Checks for equality with the object’s `slackIdentifier` field."""
  slackIdentifier: String

  """Checks for equality with the object’s `slackTeamName` field."""
  slackTeamName: String

  """Checks for equality with the object’s `hasClients` field."""
  hasClients: Boolean
}

type PaymentMethod implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  accountId: UUID!
  stripeId: String!
  last4: String
  expMonth: Int
  expYear: Int
  country: String
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID!
  brand: String

  """Reads a single `Account` that is related to this `PaymentMethod`."""
  accountByAccountId: Account

  """Reads and enables pagination through a set of `Account`."""
  accountsByCurrentPaymentMethodId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: AccountCondition
  ): AccountsConnection!
}

"""A connection to a list of `User` values."""
type UsersConnection {
  """A list of `User` objects."""
  nodes: [User]!

  """
  A list of edges which contains the `User` and cursor to aid in pagination.
  """
  edges: [UsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `User` you could get from the connection."""
  totalCount: Int!
}

"""A `User` edge in the connection."""
type UsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `User` at the end of the edge."""
  node: User
}

"""Methods to use when ordering `User`."""
enum UsersOrderBy {
  NATURAL
  EMAIL_ASC
  EMAIL_DESC
  FIRST_NAME_ASC
  FIRST_NAME_DESC
  LAST_NAME_ASC
  LAST_NAME_DESC
  ID_ASC
  ID_DESC
  PHOTO_PROCESSING_STATUS_ASC
  PHOTO_PROCESSING_STATUS_DESC
  PHOTO_PROCESSING_ERROR_ASC
  PHOTO_PROCESSING_ERROR_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  CURRENT_ACCOUNT_ID_ASC
  CURRENT_ACCOUNT_ID_DESC
  SHOW_SIDEBAR_ASC
  SHOW_SIDEBAR_DESC
  EMAIL_ON_PRODUCT_UPDATES_ASC
  EMAIL_ON_PRODUCT_UPDATES_DESC
  EMAIL_ON_MESSAGES_ASC
  EMAIL_ON_MESSAGES_DESC
  EMAIL_ON_FEEDBACK_ASC
  EMAIL_ON_FEEDBACK_DESC
  EMAIL_LIMIT_TO_DAILY_ASC
  EMAIL_LIMIT_TO_DAILY_DESC
  ENABLE_DESKTOP_NOTIFICATIONS_ASC
  ENABLE_DESKTOP_NOTIFICATIONS_DESC
  COLOR_ASC
  COLOR_DESC
  EMAIL_ON_MENTIONS_AND_ASSIGNMENTS_ASC
  EMAIL_ON_MENTIONS_AND_ASSIGNMENTS_DESC
  HAS_USED_TRIAL_ASC
  HAS_USED_TRIAL_DESC
  CURRENT_MIC_ASC
  CURRENT_MIC_DESC
  CURRENT_CAMERA_ASC
  CURRENT_CAMERA_DESC
  SHOW_TEXT_TOOLBARS_ASC
  SHOW_TEXT_TOOLBARS_DESC
  EMOJI_SKIN_TONE_ASC
  EMOJI_SKIN_TONE_DESC
  PEN_COLOR_ASC
  PEN_COLOR_DESC
  PEN_SIZE_ASC
  PEN_SIZE_DESC
  PHOTO_TEMPORARY_ASC
  PHOTO_TEMPORARY_DESC
  HAS_DESKTOP_APP_ASC
  HAS_DESKTOP_APP_DESC
  OFFER_DESKTOP_APP_ASC
  OFFER_DESKTOP_APP_DESC
  CONVERSATIONS_OPEN_ASC
  CONVERSATIONS_OPEN_DESC
  CURRENT_ROUTE_ASC
  CURRENT_ROUTE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `User` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input UserCondition {
  """Checks for equality with the object’s `email` field."""
  email: String

  """Checks for equality with the object’s `firstName` field."""
  firstName: String

  """Checks for equality with the object’s `lastName` field."""
  lastName: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `photoProcessingStatus` field."""
  photoProcessingStatus: Int

  """Checks for equality with the object’s `photoProcessingError` field."""
  photoProcessingError: String

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `currentAccountId` field."""
  currentAccountId: UUID

  """Checks for equality with the object’s `showSidebar` field."""
  showSidebar: Boolean

  """Checks for equality with the object’s `emailOnProductUpdates` field."""
  emailOnProductUpdates: Boolean

  """Checks for equality with the object’s `emailOnMessages` field."""
  emailOnMessages: Boolean

  """Checks for equality with the object’s `emailOnFeedback` field."""
  emailOnFeedback: Boolean

  """Checks for equality with the object’s `emailLimitToDaily` field."""
  emailLimitToDaily: Boolean

  """
  Checks for equality with the object’s `enableDesktopNotifications` field.
  """
  enableDesktopNotifications: Boolean

  """Checks for equality with the object’s `color` field."""
  color: String

  """
  Checks for equality with the object’s `emailOnMentionsAndAssignments` field.
  """
  emailOnMentionsAndAssignments: Boolean

  """Checks for equality with the object’s `hasUsedTrial` field."""
  hasUsedTrial: Boolean

  """Checks for equality with the object’s `currentMic` field."""
  currentMic: String

  """Checks for equality with the object’s `currentCamera` field."""
  currentCamera: String

  """Checks for equality with the object’s `showTextToolbars` field."""
  showTextToolbars: Boolean

  """Checks for equality with the object’s `emojiSkinTone` field."""
  emojiSkinTone: String

  """Checks for equality with the object’s `penColor` field."""
  penColor: String

  """Checks for equality with the object’s `penSize` field."""
  penSize: Float

  """Checks for equality with the object’s `photoTemporary` field."""
  photoTemporary: String

  """Checks for equality with the object’s `hasDesktopApp` field."""
  hasDesktopApp: Boolean

  """Checks for equality with the object’s `offerDesktopApp` field."""
  offerDesktopApp: Boolean

  """Checks for equality with the object’s `conversationsOpen` field."""
  conversationsOpen: Boolean

  """Checks for equality with the object’s `currentRoute` field."""
  currentRoute: String
}

"""A connection to a list of `Document` values."""
type DocumentsConnection {
  """A list of `Document` objects."""
  nodes: [Document]!

  """
  A list of edges which contains the `Document` and cursor to aid in pagination.
  """
  edges: [DocumentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Document` you could get from the connection."""
  totalCount: Int!
}

type Document implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String!
  slug: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID!
  figmaId: String
  figmaHash: String
  figmaName: String
  figmaKeep: Boolean
  figmaQuickHash: String
  workspaceId: UUID
  laneId: UUID!
  position: Int!
  userId: UUID
  description: String
  figmaPageUuid: String
  globalAccess: Boolean!
  archived: Boolean!
  descriptionJson: JSON
  accountId: UUID!
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
  isDemo: Boolean
  figmaSortedIds: String
  projectId: UUID
  stored: Boolean!
  storageFolderId: UUID

  """Reads a single `Workspace` that is related to this `Document`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Lane` that is related to this `Document`."""
  laneByLaneId: Lane

  """Reads a single `User` that is related to this `Document`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `Document`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Document`."""
  projectByProjectId: Project

  """Reads a single `StorageFolder` that is related to this `Document`."""
  storageFolderByStorageFolderId: StorageFolder

  """Reads and enables pagination through a set of `Email`."""
  emailsByDocumentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `Version`."""
  versionsByDocumentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: VersionCondition
  ): VersionsConnection!

  """Reads and enables pagination through a set of `DocumentUser`."""
  documentUsersByDocumentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentUserCondition
  ): DocumentUsersConnection!
}

type Workspace implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  name: String
  createdAt: Datetime!
  updatedAt: Datetime!
  slug: String
  figmaDeletedIds: JSON
  category: Int!
  id: UUID!
  projectId: UUID!
  archived: Boolean!
  globalAccess: Boolean!
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime

  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjectId: Project

  """Reads and enables pagination through a set of `Document`."""
  documentsByWorkspaceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!

  """Reads and enables pagination through a set of `Email`."""
  emailsByWorkspaceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `WorkspaceUser`."""
  workspaceUsersByWorkspaceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceUserCondition
  ): WorkspaceUsersConnection!

  """Reads and enables pagination through a set of `Lane`."""
  lanesByWorkspaceId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: LaneCondition
  ): LanesConnection!
}

type Project implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  name: String
  accountId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  archived: Boolean!
  globalAccess: Boolean!
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime

  """Reads a single `Account` that is related to this `Project`."""
  accountByAccountId: Account

  """Reads and enables pagination through a set of `Workspace`."""
  workspacesByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceCondition
  ): WorkspacesConnection!

  """Reads and enables pagination through a set of `Document`."""
  documentsByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!

  """Reads and enables pagination through a set of `Email`."""
  emailsByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `WorkspaceUser`."""
  workspaceUsersByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: WorkspaceUserCondition
  ): WorkspaceUsersConnection!

  """Reads and enables pagination through a set of `ProjectUser`."""
  projectUsersByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ProjectUserCondition
  ): ProjectUsersConnection!

  """Reads and enables pagination through a set of `StorageFolder`."""
  storageFoldersByProjectId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StorageFolderCondition
  ): StorageFoldersConnection!
}

"""A connection to a list of `Workspace` values."""
type WorkspacesConnection {
  """A list of `Workspace` objects."""
  nodes: [Workspace]!

  """
  A list of edges which contains the `Workspace` and cursor to aid in pagination.
  """
  edges: [WorkspacesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Workspace` you could get from the connection."""
  totalCount: Int!
}

"""A `Workspace` edge in the connection."""
type WorkspacesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Workspace` at the end of the edge."""
  node: Workspace
}

"""Methods to use when ordering `Workspace`."""
enum WorkspacesOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  SLUG_ASC
  SLUG_DESC
  FIGMA_DELETED_IDS_ASC
  FIGMA_DELETED_IDS_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  ID_ASC
  ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  ARCHIVED_ASC
  ARCHIVED_DESC
  GLOBAL_ACCESS_ASC
  GLOBAL_ACCESS_DESC
  GLOBAL_ACCESS_TOKEN_ASC
  GLOBAL_ACCESS_TOKEN_DESC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_ASC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Workspace` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input WorkspaceCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `figmaDeletedIds` field."""
  figmaDeletedIds: JSON

  """Checks for equality with the object’s `category` field."""
  category: Int

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `archived` field."""
  archived: Boolean

  """Checks for equality with the object’s `globalAccess` field."""
  globalAccess: Boolean

  """Checks for equality with the object’s `globalAccessToken` field."""
  globalAccessToken: String

  """
  Checks for equality with the object’s `globalAccessTokenExpiresAt` field.
  """
  globalAccessTokenExpiresAt: Datetime
}

"""Methods to use when ordering `Document`."""
enum DocumentsOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ID_ASC
  ID_DESC
  FIGMA_ID_ASC
  FIGMA_ID_DESC
  FIGMA_HASH_ASC
  FIGMA_HASH_DESC
  FIGMA_NAME_ASC
  FIGMA_NAME_DESC
  FIGMA_KEEP_ASC
  FIGMA_KEEP_DESC
  FIGMA_QUICK_HASH_ASC
  FIGMA_QUICK_HASH_DESC
  WORKSPACE_ID_ASC
  WORKSPACE_ID_DESC
  LANE_ID_ASC
  LANE_ID_DESC
  POSITION_ASC
  POSITION_DESC
  USER_ID_ASC
  USER_ID_DESC
  DESCRIPTION_ASC
  DESCRIPTION_DESC
  FIGMA_PAGE_UUID_ASC
  FIGMA_PAGE_UUID_DESC
  GLOBAL_ACCESS_ASC
  GLOBAL_ACCESS_DESC
  ARCHIVED_ASC
  ARCHIVED_DESC
  DESCRIPTION_JSON_ASC
  DESCRIPTION_JSON_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  GLOBAL_ACCESS_TOKEN_ASC
  GLOBAL_ACCESS_TOKEN_DESC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_ASC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_DESC
  IS_DEMO_ASC
  IS_DEMO_DESC
  FIGMA_SORTED_IDS_ASC
  FIGMA_SORTED_IDS_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  STORED_ASC
  STORED_DESC
  STORAGE_FOLDER_ID_ASC
  STORAGE_FOLDER_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Document` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input DocumentCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `figmaId` field."""
  figmaId: String

  """Checks for equality with the object’s `figmaHash` field."""
  figmaHash: String

  """Checks for equality with the object’s `figmaName` field."""
  figmaName: String

  """Checks for equality with the object’s `figmaKeep` field."""
  figmaKeep: Boolean

  """Checks for equality with the object’s `figmaQuickHash` field."""
  figmaQuickHash: String

  """Checks for equality with the object’s `workspaceId` field."""
  workspaceId: UUID

  """Checks for equality with the object’s `laneId` field."""
  laneId: UUID

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `description` field."""
  description: String

  """Checks for equality with the object’s `figmaPageUuid` field."""
  figmaPageUuid: String

  """Checks for equality with the object’s `globalAccess` field."""
  globalAccess: Boolean

  """Checks for equality with the object’s `archived` field."""
  archived: Boolean

  """Checks for equality with the object’s `descriptionJson` field."""
  descriptionJson: JSON

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `globalAccessToken` field."""
  globalAccessToken: String

  """
  Checks for equality with the object’s `globalAccessTokenExpiresAt` field.
  """
  globalAccessTokenExpiresAt: Datetime

  """Checks for equality with the object’s `isDemo` field."""
  isDemo: Boolean

  """Checks for equality with the object’s `figmaSortedIds` field."""
  figmaSortedIds: String

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `stored` field."""
  stored: Boolean

  """Checks for equality with the object’s `storageFolderId` field."""
  storageFolderId: UUID
}

"""A connection to a list of `Email` values."""
type EmailsConnection {
  """A list of `Email` objects."""
  nodes: [Email]!

  """
  A list of edges which contains the `Email` and cursor to aid in pagination.
  """
  edges: [EmailsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Email` you could get from the connection."""
  totalCount: Int!
}

type Email implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  category: Int
  sequenceId: BigInt
  createdAt: Datetime!
  updatedAt: Datetime!
  templateId: String
  data: JSON
  apiResponseData: JSON
  state: Int
  to: String!
  userId: UUID
  versionId: UUID
  documentId: UUID
  emailableType: String
  emailableId: UUID
  workspaceId: UUID
  accountId: UUID
  service: Int!
  projectId: UUID
  replyToName: String
  replyToEmail: String
  conversationId: UUID

  """Reads a single `Version` that is related to this `Email`."""
  versionByVersionId: Version

  """Reads a single `Document` that is related to this `Email`."""
  documentByDocumentId: Document

  """Reads a single `Workspace` that is related to this `Email`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Email`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Email`."""
  projectByProjectId: Project

  """Reads a single `Conversation` that is related to this `Email`."""
  conversationByConversationId: Conversation
}

type Version implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  slug: String
  createdAt: Datetime!
  updatedAt: Datetime!
  count: Int
  dimensions: JSON
  versionNumber: Int
  id: UUID!
  documentId: UUID!
  thumbnailProcessingStatus: Int!
  processingErrorReason: String
  firstFileIsImage: Boolean!
  userId: UUID
  figmaLink: String

  """Reads a single `Document` that is related to this `Version`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `Version`."""
  userByUserId: User

  """Reads and enables pagination through a set of `Stroke`."""
  strokesByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Stroke`."""
    orderBy: [StrokesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StrokeCondition
  ): StrokesConnection!

  """Reads and enables pagination through a set of `Recording`."""
  recordingsByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: RecordingCondition
  ): RecordingsConnection!

  """Reads and enables pagination through a set of `Email`."""
  emailsByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `Notification`."""
  notificationsByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: NotificationCondition
  ): NotificationsConnection!

  """Reads and enables pagination through a set of `Item`."""
  itemsByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Item`."""
    orderBy: [ItemsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ItemCondition
  ): ItemsConnection!

  """Reads and enables pagination through a set of `CommentThread`."""
  commentThreadsByVersionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `CommentThread`."""
    orderBy: [CommentThreadsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: CommentThreadCondition
  ): CommentThreadsConnection!
}

"""A connection to a list of `Stroke` values."""
type StrokesConnection {
  """A list of `Stroke` objects."""
  nodes: [Stroke]!

  """
  A list of edges which contains the `Stroke` and cursor to aid in pagination.
  """
  edges: [StrokesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Stroke` you could get from the connection."""
  totalCount: Int!
}

type Stroke implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  page: Int
  drawing: String
  createdAt: Datetime!
  updatedAt: Datetime!
  versionId: UUID
  screenWidth: Int

  """Reads a single `Version` that is related to this `Stroke`."""
  versionByVersionId: Version
}

"""A `Stroke` edge in the connection."""
type StrokesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Stroke` at the end of the edge."""
  node: Stroke
}

"""Methods to use when ordering `Stroke`."""
enum StrokesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  PAGE_ASC
  PAGE_DESC
  DRAWING_ASC
  DRAWING_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  SCREEN_WIDTH_ASC
  SCREEN_WIDTH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Stroke` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input StrokeCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `page` field."""
  page: Int

  """Checks for equality with the object’s `drawing` field."""
  drawing: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """Checks for equality with the object’s `screenWidth` field."""
  screenWidth: Int
}

"""A connection to a list of `Recording` values."""
type RecordingsConnection {
  """A list of `Recording` objects."""
  nodes: [Recording]!

  """
  A list of edges which contains the `Recording` and cursor to aid in pagination.
  """
  edges: [RecordingsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Recording` you could get from the connection."""
  totalCount: Int!
}

type Recording implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
  isIntro: Boolean!
  reviewer: String
  slug: String
  userId: UUID!
  page: Int!
  id: UUID!
  versionId: UUID
  thumbnailProcessingStatus: Int!
  viewedBy: JSON
  isDemo: Boolean

  """Reads a single `User` that is related to this `Recording`."""
  userByUserId: User

  """Reads a single `Version` that is related to this `Recording`."""
  versionByVersionId: Version

  """Reads and enables pagination through a set of `Transcription`."""
  transcriptionsByRecordingId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Transcription`."""
    orderBy: [TranscriptionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: TranscriptionCondition
  ): TranscriptionsConnection!
}

"""A connection to a list of `Transcription` values."""
type TranscriptionsConnection {
  """A list of `Transcription` objects."""
  nodes: [Transcription]!

  """
  A list of edges which contains the `Transcription` and cursor to aid in pagination.
  """
  edges: [TranscriptionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Transcription` you could get from the connection."""
  totalCount: Int!
}

type Transcription implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  jobName: String
  jobStatus: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  recordingId: UUID
  content: String

  """Reads a single `Recording` that is related to this `Transcription`."""
  recordingByRecordingId: Recording

  """Reads and enables pagination through a set of `Suggestion`."""
  suggestionsByTranscriptionId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Suggestion`."""
    orderBy: [SuggestionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SuggestionCondition
  ): SuggestionsConnection!
}

"""A connection to a list of `Suggestion` values."""
type SuggestionsConnection {
  """A list of `Suggestion` objects."""
  nodes: [Suggestion]!

  """
  A list of edges which contains the `Suggestion` and cursor to aid in pagination.
  """
  edges: [SuggestionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Suggestion` you could get from the connection."""
  totalCount: Int!
}

type Suggestion implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  transcriptionId: BigInt!
  content: String
  createdAt: Datetime!
  updatedAt: Datetime!
  reviewed: Boolean!

  """Reads a single `Transcription` that is related to this `Suggestion`."""
  transcriptionByTranscriptionId: Transcription
}

"""A `Suggestion` edge in the connection."""
type SuggestionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Suggestion` at the end of the edge."""
  node: Suggestion
}

"""Methods to use when ordering `Suggestion`."""
enum SuggestionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TRANSCRIPTION_ID_ASC
  TRANSCRIPTION_ID_DESC
  CONTENT_ASC
  CONTENT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  REVIEWED_ASC
  REVIEWED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Suggestion` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SuggestionCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `transcriptionId` field."""
  transcriptionId: BigInt

  """Checks for equality with the object’s `content` field."""
  content: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `reviewed` field."""
  reviewed: Boolean
}

"""A `Transcription` edge in the connection."""
type TranscriptionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Transcription` at the end of the edge."""
  node: Transcription
}

"""Methods to use when ordering `Transcription`."""
enum TranscriptionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  JOB_NAME_ASC
  JOB_NAME_DESC
  JOB_STATUS_ASC
  JOB_STATUS_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  RECORDING_ID_ASC
  RECORDING_ID_DESC
  CONTENT_ASC
  CONTENT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Transcription` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input TranscriptionCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `jobName` field."""
  jobName: String

  """Checks for equality with the object’s `jobStatus` field."""
  jobStatus: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `recordingId` field."""
  recordingId: UUID

  """Checks for equality with the object’s `content` field."""
  content: String
}

"""A `Recording` edge in the connection."""
type RecordingsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Recording` at the end of the edge."""
  node: Recording
}

"""Methods to use when ordering `Recording`."""
enum RecordingsOrderBy {
  NATURAL
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  IS_INTRO_ASC
  IS_INTRO_DESC
  REVIEWER_ASC
  REVIEWER_DESC
  SLUG_ASC
  SLUG_DESC
  USER_ID_ASC
  USER_ID_DESC
  PAGE_ASC
  PAGE_DESC
  ID_ASC
  ID_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  THUMBNAIL_PROCESSING_STATUS_ASC
  THUMBNAIL_PROCESSING_STATUS_DESC
  VIEWED_BY_ASC
  VIEWED_BY_DESC
  IS_DEMO_ASC
  IS_DEMO_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Recording` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input RecordingCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `isIntro` field."""
  isIntro: Boolean

  """Checks for equality with the object’s `reviewer` field."""
  reviewer: String

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `page` field."""
  page: Int

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """
  Checks for equality with the object’s `thumbnailProcessingStatus` field.
  """
  thumbnailProcessingStatus: Int

  """Checks for equality with the object’s `viewedBy` field."""
  viewedBy: JSON

  """Checks for equality with the object’s `isDemo` field."""
  isDemo: Boolean
}

"""Methods to use when ordering `Email`."""
enum EmailsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  SEQUENCE_ID_ASC
  SEQUENCE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  TEMPLATE_ID_ASC
  TEMPLATE_ID_DESC
  DATA_ASC
  DATA_DESC
  API_RESPONSE_DATA_ASC
  API_RESPONSE_DATA_DESC
  STATE_ASC
  STATE_DESC
  TO_ASC
  TO_DESC
  USER_ID_ASC
  USER_ID_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  DOCUMENT_ID_ASC
  DOCUMENT_ID_DESC
  EMAILABLE_TYPE_ASC
  EMAILABLE_TYPE_DESC
  EMAILABLE_ID_ASC
  EMAILABLE_ID_DESC
  WORKSPACE_ID_ASC
  WORKSPACE_ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  SERVICE_ASC
  SERVICE_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  REPLY_TO_NAME_ASC
  REPLY_TO_NAME_DESC
  REPLY_TO_EMAIL_ASC
  REPLY_TO_EMAIL_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Email` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input EmailCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `category` field."""
  category: Int

  """Checks for equality with the object’s `sequenceId` field."""
  sequenceId: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `templateId` field."""
  templateId: String

  """Checks for equality with the object’s `data` field."""
  data: JSON

  """Checks for equality with the object’s `apiResponseData` field."""
  apiResponseData: JSON

  """Checks for equality with the object’s `state` field."""
  state: Int

  """Checks for equality with the object’s `to` field."""
  to: String

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """Checks for equality with the object’s `documentId` field."""
  documentId: UUID

  """Checks for equality with the object’s `emailableType` field."""
  emailableType: String

  """Checks for equality with the object’s `emailableId` field."""
  emailableId: UUID

  """Checks for equality with the object’s `workspaceId` field."""
  workspaceId: UUID

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `service` field."""
  service: Int

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `replyToName` field."""
  replyToName: String

  """Checks for equality with the object’s `replyToEmail` field."""
  replyToEmail: String

  """Checks for equality with the object’s `conversationId` field."""
  conversationId: UUID
}

"""A connection to a list of `Notification` values."""
type NotificationsConnection {
  """A list of `Notification` objects."""
  nodes: [Notification]!

  """
  A list of edges which contains the `Notification` and cursor to aid in pagination.
  """
  edges: [NotificationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Notification` you could get from the connection."""
  totalCount: Int!
}

type Notification implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  category: Int!
  read: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  userId: UUID!
  id: UUID!
  originatorId: UUID!
  page: Int
  versionId: UUID
  notifiableType: String!
  notifiableId: UUID!
  screenWidth: Int
  notifiablePageType: String!
  notifiablePageId: UUID!
  accountId: UUID!
  dropdownPage: Int!

  """Reads a single `User` that is related to this `Notification`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Notification`."""
  userByOriginatorId: User

  """Reads a single `Version` that is related to this `Notification`."""
  versionByVersionId: Version

  """Reads a single `Account` that is related to this `Notification`."""
  accountByAccountId: Account
}

"""A `Notification` edge in the connection."""
type NotificationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Notification` at the end of the edge."""
  node: Notification
}

"""Methods to use when ordering `Notification`."""
enum NotificationsOrderBy {
  NATURAL
  CATEGORY_ASC
  CATEGORY_DESC
  READ_ASC
  READ_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  USER_ID_ASC
  USER_ID_DESC
  ID_ASC
  ID_DESC
  ORIGINATOR_ID_ASC
  ORIGINATOR_ID_DESC
  PAGE_ASC
  PAGE_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  NOTIFIABLE_TYPE_ASC
  NOTIFIABLE_TYPE_DESC
  NOTIFIABLE_ID_ASC
  NOTIFIABLE_ID_DESC
  SCREEN_WIDTH_ASC
  SCREEN_WIDTH_DESC
  NOTIFIABLE_PAGE_TYPE_ASC
  NOTIFIABLE_PAGE_TYPE_DESC
  NOTIFIABLE_PAGE_ID_ASC
  NOTIFIABLE_PAGE_ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  DROPDOWN_PAGE_ASC
  DROPDOWN_PAGE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Notification` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input NotificationCondition {
  """Checks for equality with the object’s `category` field."""
  category: Int

  """Checks for equality with the object’s `read` field."""
  read: Boolean

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `originatorId` field."""
  originatorId: UUID

  """Checks for equality with the object’s `page` field."""
  page: Int

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """Checks for equality with the object’s `notifiableType` field."""
  notifiableType: String

  """Checks for equality with the object’s `notifiableId` field."""
  notifiableId: UUID

  """Checks for equality with the object’s `screenWidth` field."""
  screenWidth: Int

  """Checks for equality with the object’s `notifiablePageType` field."""
  notifiablePageType: String

  """Checks for equality with the object’s `notifiablePageId` field."""
  notifiablePageId: UUID

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `dropdownPage` field."""
  dropdownPage: Int
}

"""A connection to a list of `Item` values."""
type ItemsConnection {
  """A list of `Item` objects."""
  nodes: [Item]!

  """
  A list of edges which contains the `Item` and cursor to aid in pagination.
  """
  edges: [ItemsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Item` you could get from the connection."""
  totalCount: Int!
}

type Item implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  type: String
  pages: Int
  width: Int
  height: Int
  contentType: String
  url: String
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int!
  id: UUID!
  versionId: UUID
  processingStatus: Int!
  processingErrorReason: String
  positionX: Int
  positionY: Int
  pageWidth: Int
  figmaHash: String
  figmaQuickHash: String

  """Reads a single `Version` that is related to this `Item`."""
  versionByVersionId: Version

  """Reads and enables pagination through a set of `SiteFile`."""
  siteFilesByItemId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `SiteFile`."""
    orderBy: [SiteFilesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: SiteFileCondition
  ): SiteFilesConnection!
}

"""A connection to a list of `SiteFile` values."""
type SiteFilesConnection {
  """A list of `SiteFile` objects."""
  nodes: [SiteFile]!

  """
  A list of edges which contains the `SiteFile` and cursor to aid in pagination.
  """
  edges: [SiteFilesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `SiteFile` you could get from the connection."""
  totalCount: Int!
}

type SiteFile implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  createdAt: Datetime!
  updatedAt: Datetime!
  filename: String
  itemId: UUID
  id: UUID!

  """Reads a single `Item` that is related to this `SiteFile`."""
  itemByItemId: Item
}

"""A `SiteFile` edge in the connection."""
type SiteFilesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SiteFile` at the end of the edge."""
  node: SiteFile
}

"""Methods to use when ordering `SiteFile`."""
enum SiteFilesOrderBy {
  NATURAL
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  FILENAME_ASC
  FILENAME_DESC
  ITEM_ID_ASC
  ITEM_ID_DESC
  ID_ASC
  ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SiteFile` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SiteFileCondition {
  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `filename` field."""
  filename: String

  """Checks for equality with the object’s `itemId` field."""
  itemId: UUID

  """Checks for equality with the object’s `id` field."""
  id: UUID
}

"""A `Item` edge in the connection."""
type ItemsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Item` at the end of the edge."""
  node: Item
}

"""Methods to use when ordering `Item`."""
enum ItemsOrderBy {
  NATURAL
  TYPE_ASC
  TYPE_DESC
  PAGES_ASC
  PAGES_DESC
  WIDTH_ASC
  WIDTH_DESC
  HEIGHT_ASC
  HEIGHT_DESC
  CONTENT_TYPE_ASC
  CONTENT_TYPE_DESC
  URL_ASC
  URL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSITION_ASC
  POSITION_DESC
  ID_ASC
  ID_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  PROCESSING_STATUS_ASC
  PROCESSING_STATUS_DESC
  PROCESSING_ERROR_REASON_ASC
  PROCESSING_ERROR_REASON_DESC
  POSITION_X_ASC
  POSITION_X_DESC
  POSITION_Y_ASC
  POSITION_Y_DESC
  PAGE_WIDTH_ASC
  PAGE_WIDTH_DESC
  FIGMA_HASH_ASC
  FIGMA_HASH_DESC
  FIGMA_QUICK_HASH_ASC
  FIGMA_QUICK_HASH_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Item` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ItemCondition {
  """Checks for equality with the object’s `type` field."""
  type: String

  """Checks for equality with the object’s `pages` field."""
  pages: Int

  """Checks for equality with the object’s `width` field."""
  width: Int

  """Checks for equality with the object’s `height` field."""
  height: Int

  """Checks for equality with the object’s `contentType` field."""
  contentType: String

  """Checks for equality with the object’s `url` field."""
  url: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """Checks for equality with the object’s `processingStatus` field."""
  processingStatus: Int

  """Checks for equality with the object’s `processingErrorReason` field."""
  processingErrorReason: String

  """Checks for equality with the object’s `positionX` field."""
  positionX: Int

  """Checks for equality with the object’s `positionY` field."""
  positionY: Int

  """Checks for equality with the object’s `pageWidth` field."""
  pageWidth: Int

  """Checks for equality with the object’s `figmaHash` field."""
  figmaHash: String

  """Checks for equality with the object’s `figmaQuickHash` field."""
  figmaQuickHash: String
}

"""A connection to a list of `CommentThread` values."""
type CommentThreadsConnection {
  """A list of `CommentThread` objects."""
  nodes: [CommentThread]!

  """
  A list of edges which contains the `CommentThread` and cursor to aid in pagination.
  """
  edges: [CommentThreadsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `CommentThread` you could get from the connection."""
  totalCount: Int!
}

type CommentThread implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  positionX: Int
  positionY: Int
  page: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID!
  versionId: UUID
  screenWidth: Int
  resolved: Boolean!
  position: Int!
  elementId: String
  positionPercentageX: Float
  positionPercentageY: Float

  """Reads a single `Version` that is related to this `CommentThread`."""
  versionByVersionId: Version
}

"""A `CommentThread` edge in the connection."""
type CommentThreadsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `CommentThread` at the end of the edge."""
  node: CommentThread
}

"""Methods to use when ordering `CommentThread`."""
enum CommentThreadsOrderBy {
  NATURAL
  POSITION_X_ASC
  POSITION_X_DESC
  POSITION_Y_ASC
  POSITION_Y_DESC
  PAGE_ASC
  PAGE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ID_ASC
  ID_DESC
  VERSION_ID_ASC
  VERSION_ID_DESC
  SCREEN_WIDTH_ASC
  SCREEN_WIDTH_DESC
  RESOLVED_ASC
  RESOLVED_DESC
  POSITION_ASC
  POSITION_DESC
  ELEMENT_ID_ASC
  ELEMENT_ID_DESC
  POSITION_PERCENTAGE_X_ASC
  POSITION_PERCENTAGE_X_DESC
  POSITION_PERCENTAGE_Y_ASC
  POSITION_PERCENTAGE_Y_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `CommentThread` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input CommentThreadCondition {
  """Checks for equality with the object’s `positionX` field."""
  positionX: Int

  """Checks for equality with the object’s `positionY` field."""
  positionY: Int

  """Checks for equality with the object’s `page` field."""
  page: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `versionId` field."""
  versionId: UUID

  """Checks for equality with the object’s `screenWidth` field."""
  screenWidth: Int

  """Checks for equality with the object’s `resolved` field."""
  resolved: Boolean

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `elementId` field."""
  elementId: String

  """Checks for equality with the object’s `positionPercentageX` field."""
  positionPercentageX: Float

  """Checks for equality with the object’s `positionPercentageY` field."""
  positionPercentageY: Float
}

type Conversation implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  accountId: UUID!
  slug: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Account` that is related to this `Conversation`."""
  accountByAccountId: Account

  """Reads and enables pagination through a set of `Email`."""
  emailsByConversationId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: EmailCondition
  ): EmailsConnection!

  """Reads and enables pagination through a set of `ConversationUser`."""
  conversationUsersByConversationId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ConversationUserCondition
  ): ConversationUsersConnection!
}

"""A connection to a list of `ConversationUser` values."""
type ConversationUsersConnection {
  """A list of `ConversationUser` objects."""
  nodes: [ConversationUser]!

  """
  A list of edges which contains the `ConversationUser` and cursor to aid in pagination.
  """
  edges: [ConversationUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ConversationUser` you could get from the connection.
  """
  totalCount: Int!
}

type ConversationUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  conversationId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int!
  lastReadDiscussionAt: Datetime!
  position: Int!
  muted: Boolean!
  visible: Boolean!
  lastViewed: Datetime
  name: String!

  """
  Reads a single `Conversation` that is related to this `ConversationUser`.
  """
  conversationByConversationId: Conversation

  """Reads a single `User` that is related to this `ConversationUser`."""
  userByUserId: User
}

"""A `ConversationUser` edge in the connection."""
type ConversationUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ConversationUser` at the end of the edge."""
  node: ConversationUser
}

"""Methods to use when ordering `ConversationUser`."""
enum ConversationUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CONVERSATION_ID_ASC
  CONVERSATION_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  LAST_READ_DISCUSSION_AT_ASC
  LAST_READ_DISCUSSION_AT_DESC
  POSITION_ASC
  POSITION_DESC
  MUTED_ASC
  MUTED_DESC
  VISIBLE_ASC
  VISIBLE_DESC
  LAST_VIEWED_ASC
  LAST_VIEWED_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ConversationUser` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ConversationUserCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `conversationId` field."""
  conversationId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `lastReadDiscussionAt` field."""
  lastReadDiscussionAt: Datetime

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `muted` field."""
  muted: Boolean

  """Checks for equality with the object’s `visible` field."""
  visible: Boolean

  """Checks for equality with the object’s `lastViewed` field."""
  lastViewed: Datetime

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A `Email` edge in the connection."""
type EmailsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Email` at the end of the edge."""
  node: Email
}

"""A connection to a list of `WorkspaceUser` values."""
type WorkspaceUsersConnection {
  """A list of `WorkspaceUser` objects."""
  nodes: [WorkspaceUser]!

  """
  A list of edges which contains the `WorkspaceUser` and cursor to aid in pagination.
  """
  edges: [WorkspaceUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `WorkspaceUser` you could get from the connection."""
  totalCount: Int!
}

type WorkspaceUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int!
  guest: Boolean!
  lastViewed: Datetime
  workspaceId: UUID!
  lastReadDiscussionAt: Datetime!
  id: UUID!
  position: Int!
  projectId: UUID!
  muted: Boolean!

  """Reads a single `User` that is related to this `WorkspaceUser`."""
  userByUserId: User

  """Reads a single `Workspace` that is related to this `WorkspaceUser`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Project` that is related to this `WorkspaceUser`."""
  projectByProjectId: Project
}

"""A `WorkspaceUser` edge in the connection."""
type WorkspaceUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `WorkspaceUser` at the end of the edge."""
  node: WorkspaceUser
}

"""Methods to use when ordering `WorkspaceUser`."""
enum WorkspaceUsersOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  GUEST_ASC
  GUEST_DESC
  LAST_VIEWED_ASC
  LAST_VIEWED_DESC
  WORKSPACE_ID_ASC
  WORKSPACE_ID_DESC
  LAST_READ_DISCUSSION_AT_ASC
  LAST_READ_DISCUSSION_AT_DESC
  ID_ASC
  ID_DESC
  POSITION_ASC
  POSITION_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  MUTED_ASC
  MUTED_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `WorkspaceUser` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input WorkspaceUserCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `guest` field."""
  guest: Boolean

  """Checks for equality with the object’s `lastViewed` field."""
  lastViewed: Datetime

  """Checks for equality with the object’s `workspaceId` field."""
  workspaceId: UUID

  """Checks for equality with the object’s `lastReadDiscussionAt` field."""
  lastReadDiscussionAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `muted` field."""
  muted: Boolean
}

"""A connection to a list of `ProjectUser` values."""
type ProjectUsersConnection {
  """A list of `ProjectUser` objects."""
  nodes: [ProjectUser]!

  """
  A list of edges which contains the `ProjectUser` and cursor to aid in pagination.
  """
  edges: [ProjectUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ProjectUser` you could get from the connection."""
  totalCount: Int!
}

type ProjectUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  userId: UUID!
  projectId: UUID!
  notificationCount: Int!
  guest: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int!
  accountId: UUID!
  specificWorkspacesOnly: Boolean!
  workspaceBarOpen: Boolean!

  """Reads a single `User` that is related to this `ProjectUser`."""
  userByUserId: User

  """Reads a single `Project` that is related to this `ProjectUser`."""
  projectByProjectId: Project

  """Reads a single `Account` that is related to this `ProjectUser`."""
  accountByAccountId: Account
}

"""A `ProjectUser` edge in the connection."""
type ProjectUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ProjectUser` at the end of the edge."""
  node: ProjectUser
}

"""Methods to use when ordering `ProjectUser`."""
enum ProjectUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  GUEST_ASC
  GUEST_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSITION_ASC
  POSITION_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  SPECIFIC_WORKSPACES_ONLY_ASC
  SPECIFIC_WORKSPACES_ONLY_DESC
  WORKSPACE_BAR_OPEN_ASC
  WORKSPACE_BAR_OPEN_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ProjectUser` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ProjectUserCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `guest` field."""
  guest: Boolean

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `specificWorkspacesOnly` field."""
  specificWorkspacesOnly: Boolean

  """Checks for equality with the object’s `workspaceBarOpen` field."""
  workspaceBarOpen: Boolean
}

"""A connection to a list of `StorageFolder` values."""
type StorageFoldersConnection {
  """A list of `StorageFolder` objects."""
  nodes: [StorageFolder]!

  """
  A list of edges which contains the `StorageFolder` and cursor to aid in pagination.
  """
  edges: [StorageFoldersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `StorageFolder` you could get from the connection."""
  totalCount: Int!
}

type StorageFolder implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  name: String
  accountId: UUID!
  parentId: UUID
  projectId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Account` that is related to this `StorageFolder`."""
  accountByAccountId: Account

  """
  Reads a single `StorageFolder` that is related to this `StorageFolder`.
  """
  storageFolderByParentId: StorageFolder

  """Reads a single `Project` that is related to this `StorageFolder`."""
  projectByProjectId: Project

  """Reads and enables pagination through a set of `Document`."""
  documentsByStorageFolderId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!

  """Reads and enables pagination through a set of `StorageFolder`."""
  storageFoldersByParentId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: StorageFolderCondition
  ): StorageFoldersConnection!
}

"""Methods to use when ordering `StorageFolder`."""
enum StorageFoldersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  PARENT_ID_ASC
  PARENT_ID_DESC
  PROJECT_ID_ASC
  PROJECT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `StorageFolder` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input StorageFolderCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `parentId` field."""
  parentId: UUID

  """Checks for equality with the object’s `projectId` field."""
  projectId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `StorageFolder` edge in the connection."""
type StorageFoldersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `StorageFolder` at the end of the edge."""
  node: StorageFolder
}

"""A connection to a list of `Lane` values."""
type LanesConnection {
  """A list of `Lane` objects."""
  nodes: [Lane]!

  """
  A list of edges which contains the `Lane` and cursor to aid in pagination.
  """
  edges: [LanesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Lane` you could get from the connection."""
  totalCount: Int!
}

type Lane implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  workspaceId: UUID
  name: String!
  label: String
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int!
  accountId: UUID!

  """Reads a single `Workspace` that is related to this `Lane`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Lane`."""
  accountByAccountId: Account

  """Reads and enables pagination through a set of `Document`."""
  documentsByLaneId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: DocumentCondition
  ): DocumentsConnection!
}

"""A `Lane` edge in the connection."""
type LanesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Lane` at the end of the edge."""
  node: Lane
}

"""Methods to use when ordering `Lane`."""
enum LanesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  WORKSPACE_ID_ASC
  WORKSPACE_ID_DESC
  NAME_ASC
  NAME_DESC
  LABEL_ASC
  LABEL_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  POSITION_ASC
  POSITION_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Lane` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input LaneCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `workspaceId` field."""
  workspaceId: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `label` field."""
  label: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID
}

"""A connection to a list of `Version` values."""
type VersionsConnection {
  """A list of `Version` objects."""
  nodes: [Version]!

  """
  A list of edges which contains the `Version` and cursor to aid in pagination.
  """
  edges: [VersionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Version` you could get from the connection."""
  totalCount: Int!
}

"""A `Version` edge in the connection."""
type VersionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Version` at the end of the edge."""
  node: Version
}

"""Methods to use when ordering `Version`."""
enum VersionsOrderBy {
  NATURAL
  SLUG_ASC
  SLUG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  COUNT_ASC
  COUNT_DESC
  DIMENSIONS_ASC
  DIMENSIONS_DESC
  VERSION_NUMBER_ASC
  VERSION_NUMBER_DESC
  ID_ASC
  ID_DESC
  DOCUMENT_ID_ASC
  DOCUMENT_ID_DESC
  THUMBNAIL_PROCESSING_STATUS_ASC
  THUMBNAIL_PROCESSING_STATUS_DESC
  PROCESSING_ERROR_REASON_ASC
  PROCESSING_ERROR_REASON_DESC
  FIRST_FILE_IS_IMAGE_ASC
  FIRST_FILE_IS_IMAGE_DESC
  USER_ID_ASC
  USER_ID_DESC
  FIGMA_LINK_ASC
  FIGMA_LINK_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Version` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input VersionCondition {
  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `count` field."""
  count: Int

  """Checks for equality with the object’s `dimensions` field."""
  dimensions: JSON

  """Checks for equality with the object’s `versionNumber` field."""
  versionNumber: Int

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `documentId` field."""
  documentId: UUID

  """
  Checks for equality with the object’s `thumbnailProcessingStatus` field.
  """
  thumbnailProcessingStatus: Int

  """Checks for equality with the object’s `processingErrorReason` field."""
  processingErrorReason: String

  """Checks for equality with the object’s `firstFileIsImage` field."""
  firstFileIsImage: Boolean

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `figmaLink` field."""
  figmaLink: String
}

"""A connection to a list of `DocumentUser` values."""
type DocumentUsersConnection {
  """A list of `DocumentUser` objects."""
  nodes: [DocumentUser]!

  """
  A list of edges which contains the `DocumentUser` and cursor to aid in pagination.
  """
  edges: [DocumentUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `DocumentUser` you could get from the connection."""
  totalCount: Int!
}

type DocumentUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int!
  lastViewed: Datetime
  documentId: UUID!
  lastReadDiscussionAt: Datetime
  guest: Boolean!
  id: UUID!
  assigned: Boolean!
  assignerId: UUID
  observer: Boolean!

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByUserId: User

  """Reads a single `Document` that is related to this `DocumentUser`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByAssignerId: User
}

"""A `DocumentUser` edge in the connection."""
type DocumentUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `DocumentUser` at the end of the edge."""
  node: DocumentUser
}

"""Methods to use when ordering `DocumentUser`."""
enum DocumentUsersOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  LAST_VIEWED_ASC
  LAST_VIEWED_DESC
  DOCUMENT_ID_ASC
  DOCUMENT_ID_DESC
  LAST_READ_DISCUSSION_AT_ASC
  LAST_READ_DISCUSSION_AT_DESC
  GUEST_ASC
  GUEST_DESC
  ID_ASC
  ID_DESC
  ASSIGNED_ASC
  ASSIGNED_DESC
  ASSIGNER_ID_ASC
  ASSIGNER_ID_DESC
  OBSERVER_ASC
  OBSERVER_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `DocumentUser` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input DocumentUserCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `lastViewed` field."""
  lastViewed: Datetime

  """Checks for equality with the object’s `documentId` field."""
  documentId: UUID

  """Checks for equality with the object’s `lastReadDiscussionAt` field."""
  lastReadDiscussionAt: Datetime

  """Checks for equality with the object’s `guest` field."""
  guest: Boolean

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `assigned` field."""
  assigned: Boolean

  """Checks for equality with the object’s `assignerId` field."""
  assignerId: UUID

  """Checks for equality with the object’s `observer` field."""
  observer: Boolean
}

"""A `Document` edge in the connection."""
type DocumentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Document` at the end of the edge."""
  node: Document
}

"""Methods to use when ordering `AccountUser`."""
enum AccountUsersOrderBy {
  NATURAL
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  NOTIFICATION_COUNT_ASC
  NOTIFICATION_COUNT_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  VIEWER_ASC
  VIEWER_DESC
  ID_ASC
  ID_DESC
  POSITION_ASC
  POSITION_DESC
  SHOW_RECENT_ASC
  SHOW_RECENT_DESC
  SHOW_SHARED_ASC
  SHOW_SHARED_DESC
  SPECIFIC_PROJECTS_ONLY_ASC
  SPECIFIC_PROJECTS_ONLY_DESC
  LAST_VIEWED_SHARED_AT_ASC
  LAST_VIEWED_SHARED_AT_DESC
  LAST_VIEWED_RECENT_AT_ASC
  LAST_VIEWED_RECENT_AT_DESC
  LAST_VIEWED_FEED_AT_ASC
  LAST_VIEWED_FEED_AT_DESC
  SLACK_EMAIL_ASC
  SLACK_EMAIL_DESC
  SLACK_ID_ASC
  SLACK_ID_DESC
  SHARED_NOTIFICATION_COUNT_ASC
  SHARED_NOTIFICATION_COUNT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `AccountUser` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input AccountUserCondition {
  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `notificationCount` field."""
  notificationCount: Int

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `viewer` field."""
  viewer: Boolean

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `showRecent` field."""
  showRecent: Boolean

  """Checks for equality with the object’s `showShared` field."""
  showShared: Boolean

  """Checks for equality with the object’s `specificProjectsOnly` field."""
  specificProjectsOnly: Boolean

  """Checks for equality with the object’s `lastViewedSharedAt` field."""
  lastViewedSharedAt: Datetime

  """Checks for equality with the object’s `lastViewedRecentAt` field."""
  lastViewedRecentAt: Datetime

  """Checks for equality with the object’s `lastViewedFeedAt` field."""
  lastViewedFeedAt: Datetime

  """Checks for equality with the object’s `slackEmail` field."""
  slackEmail: String

  """Checks for equality with the object’s `slackId` field."""
  slackId: String

  """Checks for equality with the object’s `sharedNotificationCount` field."""
  sharedNotificationCount: Int
}

"""A connection to a list of `PaymentMethod` values."""
type PaymentMethodsConnection {
  """A list of `PaymentMethod` objects."""
  nodes: [PaymentMethod]!

  """
  A list of edges which contains the `PaymentMethod` and cursor to aid in pagination.
  """
  edges: [PaymentMethodsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `PaymentMethod` you could get from the connection."""
  totalCount: Int!
}

"""A `PaymentMethod` edge in the connection."""
type PaymentMethodsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PaymentMethod` at the end of the edge."""
  node: PaymentMethod
}

"""Methods to use when ordering `PaymentMethod`."""
enum PaymentMethodsOrderBy {
  NATURAL
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  STRIPE_ID_ASC
  STRIPE_ID_DESC
  LAST4_ASC
  LAST4_DESC
  EXP_MONTH_ASC
  EXP_MONTH_DESC
  EXP_YEAR_ASC
  EXP_YEAR_DESC
  COUNTRY_ASC
  COUNTRY_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ID_ASC
  ID_DESC
  BRAND_ASC
  BRAND_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PaymentMethod` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PaymentMethodCondition {
  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `stripeId` field."""
  stripeId: String

  """Checks for equality with the object’s `last4` field."""
  last4: String

  """Checks for equality with the object’s `expMonth` field."""
  expMonth: Int

  """Checks for equality with the object’s `expYear` field."""
  expYear: Int

  """Checks for equality with the object’s `country` field."""
  country: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `brand` field."""
  brand: String
}

"""A connection to a list of `Project` values."""
type ProjectsConnection {
  """A list of `Project` objects."""
  nodes: [Project]!

  """
  A list of edges which contains the `Project` and cursor to aid in pagination.
  """
  edges: [ProjectsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Project` you could get from the connection."""
  totalCount: Int!
}

"""A `Project` edge in the connection."""
type ProjectsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Project` at the end of the edge."""
  node: Project
}

"""Methods to use when ordering `Project`."""
enum ProjectsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ARCHIVED_ASC
  ARCHIVED_DESC
  GLOBAL_ACCESS_ASC
  GLOBAL_ACCESS_DESC
  GLOBAL_ACCESS_TOKEN_ASC
  GLOBAL_ACCESS_TOKEN_DESC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_ASC
  GLOBAL_ACCESS_TOKEN_EXPIRES_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Project` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input ProjectCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `archived` field."""
  archived: Boolean

  """Checks for equality with the object’s `globalAccess` field."""
  globalAccess: Boolean

  """Checks for equality with the object’s `globalAccessToken` field."""
  globalAccessToken: String

  """
  Checks for equality with the object’s `globalAccessTokenExpiresAt` field.
  """
  globalAccessTokenExpiresAt: Datetime
}

"""A connection to a list of `Conversation` values."""
type ConversationsConnection {
  """A list of `Conversation` objects."""
  nodes: [Conversation]!

  """
  A list of edges which contains the `Conversation` and cursor to aid in pagination.
  """
  edges: [ConversationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Conversation` you could get from the connection."""
  totalCount: Int!
}

"""A `Conversation` edge in the connection."""
type ConversationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Conversation` at the end of the edge."""
  node: Conversation
}

"""Methods to use when ordering `Conversation`."""
enum ConversationsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  SLUG_ASC
  SLUG_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Conversation` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ConversationCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `Sequence` values."""
type SequencesConnection {
  """A list of `Sequence` objects."""
  nodes: [Sequence]!

  """
  A list of edges which contains the `Sequence` and cursor to aid in pagination.
  """
  edges: [SequencesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Sequence` you could get from the connection."""
  totalCount: Int!
}

type Sequence implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  createdAt: Datetime!
  updatedAt: Datetime!
  frequency: String!
  linkClicked: Boolean
  unsubscribed: Boolean
  emailsSent: Int!
  lastSentAt: Datetime
  nextJobId: String
  cancelled: Boolean
  userId: UUID!
  senderId: UUID
  sequencableType: String!
  sequencableId: UUID
  message: String
  subject: String

  """Reads a single `User` that is related to this `Sequence`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Sequence`."""
  userBySenderId: User
}

"""A `Sequence` edge in the connection."""
type SequencesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Sequence` at the end of the edge."""
  node: Sequence
}

"""Methods to use when ordering `Sequence`."""
enum SequencesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  FREQUENCY_ASC
  FREQUENCY_DESC
  LINK_CLICKED_ASC
  LINK_CLICKED_DESC
  UNSUBSCRIBED_ASC
  UNSUBSCRIBED_DESC
  EMAILS_SENT_ASC
  EMAILS_SENT_DESC
  LAST_SENT_AT_ASC
  LAST_SENT_AT_DESC
  NEXT_JOB_ID_ASC
  NEXT_JOB_ID_DESC
  CANCELLED_ASC
  CANCELLED_DESC
  USER_ID_ASC
  USER_ID_DESC
  SENDER_ID_ASC
  SENDER_ID_DESC
  SEQUENCABLE_TYPE_ASC
  SEQUENCABLE_TYPE_DESC
  SEQUENCABLE_ID_ASC
  SEQUENCABLE_ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  SUBJECT_ASC
  SUBJECT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Sequence` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input SequenceCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `frequency` field."""
  frequency: String

  """Checks for equality with the object’s `linkClicked` field."""
  linkClicked: Boolean

  """Checks for equality with the object’s `unsubscribed` field."""
  unsubscribed: Boolean

  """Checks for equality with the object’s `emailsSent` field."""
  emailsSent: Int

  """Checks for equality with the object’s `lastSentAt` field."""
  lastSentAt: Datetime

  """Checks for equality with the object’s `nextJobId` field."""
  nextJobId: String

  """Checks for equality with the object’s `cancelled` field."""
  cancelled: Boolean

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `senderId` field."""
  senderId: UUID

  """Checks for equality with the object’s `sequencableType` field."""
  sequencableType: String

  """Checks for equality with the object’s `sequencableId` field."""
  sequencableId: UUID

  """Checks for equality with the object’s `message` field."""
  message: String

  """Checks for equality with the object’s `subject` field."""
  subject: String
}

"""A connection to a list of `Message` values."""
type MessagesConnection {
  """A list of `Message` objects."""
  nodes: [Message]!

  """
  A list of edges which contains the `Message` and cursor to aid in pagination.
  """
  edges: [MessagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Message` you could get from the connection."""
  totalCount: Int!
}

type Message implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  userId: UUID!
  text: String
  messagableId: UUID
  messagableType: String
  createdAt: Datetime!
  updatedAt: Datetime!
  category: Int!
  threadableId: UUID
  threadableType: String
  replyCount: Int!
  textJson: JSON
  isDemo: Boolean

  """Reads a single `User` that is related to this `Message`."""
  userByUserId: User

  """Reads and enables pagination through a set of `MessageFile`."""
  messageFilesByMessageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MessageFile`."""
    orderBy: [MessageFilesOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageFileCondition
  ): MessageFilesConnection!

  """Reads and enables pagination through a set of `MessageUser`."""
  messageUsersByMessageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: MessageUserCondition
  ): MessageUsersConnection!

  """Reads and enables pagination through a set of `Reaction`."""
  reactionsByMessageId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ReactionCondition
  ): ReactionsConnection!
}

"""A connection to a list of `MessageFile` values."""
type MessageFilesConnection {
  """A list of `MessageFile` objects."""
  nodes: [MessageFile]!

  """
  A list of edges which contains the `MessageFile` and cursor to aid in pagination.
  """
  edges: [MessageFilesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MessageFile` you could get from the connection."""
  totalCount: Int!
}

type MessageFile implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  messageId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
  thumbnailProcessingStatus: Int!
  thumbnailProcessingError: String
  name: String!

  """Reads a single `Message` that is related to this `MessageFile`."""
  messageByMessageId: Message
}

"""A `MessageFile` edge in the connection."""
type MessageFilesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MessageFile` at the end of the edge."""
  node: MessageFile
}

"""Methods to use when ordering `MessageFile`."""
enum MessageFilesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MESSAGE_ID_ASC
  MESSAGE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  THUMBNAIL_PROCESSING_STATUS_ASC
  THUMBNAIL_PROCESSING_STATUS_DESC
  THUMBNAIL_PROCESSING_ERROR_ASC
  THUMBNAIL_PROCESSING_ERROR_DESC
  NAME_ASC
  NAME_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `MessageFile` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MessageFileCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `messageId` field."""
  messageId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """
  Checks for equality with the object’s `thumbnailProcessingStatus` field.
  """
  thumbnailProcessingStatus: Int

  """
  Checks for equality with the object’s `thumbnailProcessingError` field.
  """
  thumbnailProcessingError: String

  """Checks for equality with the object’s `name` field."""
  name: String
}

"""A connection to a list of `MessageUser` values."""
type MessageUsersConnection {
  """A list of `MessageUser` objects."""
  nodes: [MessageUser]!

  """
  A list of edges which contains the `MessageUser` and cursor to aid in pagination.
  """
  edges: [MessageUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `MessageUser` you could get from the connection."""
  totalCount: Int!
}

type MessageUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  messageId: UUID!
  userId: UUID!
  lastReadDiscussionAt: Datetime!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Message` that is related to this `MessageUser`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `MessageUser`."""
  userByUserId: User
}

"""A `MessageUser` edge in the connection."""
type MessageUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `MessageUser` at the end of the edge."""
  node: MessageUser
}

"""Methods to use when ordering `MessageUser`."""
enum MessageUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MESSAGE_ID_ASC
  MESSAGE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  LAST_READ_DISCUSSION_AT_ASC
  LAST_READ_DISCUSSION_AT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `MessageUser` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input MessageUserCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `messageId` field."""
  messageId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `lastReadDiscussionAt` field."""
  lastReadDiscussionAt: Datetime

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `Reaction` values."""
type ReactionsConnection {
  """A list of `Reaction` objects."""
  nodes: [Reaction]!

  """
  A list of edges which contains the `Reaction` and cursor to aid in pagination.
  """
  edges: [ReactionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Reaction` you could get from the connection."""
  totalCount: Int!
}

type Reaction implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  messageId: UUID!
  userId: UUID!
  text: String
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `Message` that is related to this `Reaction`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `Reaction`."""
  userByUserId: User
}

"""A `Reaction` edge in the connection."""
type ReactionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Reaction` at the end of the edge."""
  node: Reaction
}

"""Methods to use when ordering `Reaction`."""
enum ReactionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MESSAGE_ID_ASC
  MESSAGE_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TEXT_ASC
  TEXT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Reaction` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ReactionCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `messageId` field."""
  messageId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `text` field."""
  text: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `Message` edge in the connection."""
type MessagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Message` at the end of the edge."""
  node: Message
}

"""Methods to use when ordering `Message`."""
enum MessagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TEXT_ASC
  TEXT_DESC
  MESSAGABLE_ID_ASC
  MESSAGABLE_ID_DESC
  MESSAGABLE_TYPE_ASC
  MESSAGABLE_TYPE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  CATEGORY_ASC
  CATEGORY_DESC
  THREADABLE_ID_ASC
  THREADABLE_ID_DESC
  THREADABLE_TYPE_ASC
  THREADABLE_TYPE_DESC
  REPLY_COUNT_ASC
  REPLY_COUNT_DESC
  TEXT_JSON_ASC
  TEXT_JSON_DESC
  IS_DEMO_ASC
  IS_DEMO_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Message` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MessageCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `text` field."""
  text: String

  """Checks for equality with the object’s `messagableId` field."""
  messagableId: UUID

  """Checks for equality with the object’s `messagableType` field."""
  messagableType: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `category` field."""
  category: Int

  """Checks for equality with the object’s `threadableId` field."""
  threadableId: UUID

  """Checks for equality with the object’s `threadableType` field."""
  threadableType: String

  """Checks for equality with the object’s `replyCount` field."""
  replyCount: Int

  """Checks for equality with the object’s `textJson` field."""
  textJson: JSON

  """Checks for equality with the object’s `isDemo` field."""
  isDemo: Boolean
}

"""A connection to a list of `ContactUser` values."""
type ContactUsersConnection {
  """A list of `ContactUser` objects."""
  nodes: [ContactUser]!

  """
  A list of edges which contains the `ContactUser` and cursor to aid in pagination.
  """
  edges: [ContactUsersEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `ContactUser` you could get from the connection."""
  totalCount: Int!
}

type ContactUser implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  contactId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `ContactUser`."""
  userByContactId: User

  """Reads a single `User` that is related to this `ContactUser`."""
  userByUserId: User
}

"""A `ContactUser` edge in the connection."""
type ContactUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ContactUser` at the end of the edge."""
  node: ContactUser
}

"""Methods to use when ordering `ContactUser`."""
enum ContactUsersOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  CONTACT_ID_ASC
  CONTACT_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ContactUser` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input ContactUserCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `contactId` field."""
  contactId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `Mention` values."""
type MentionsConnection {
  """A list of `Mention` objects."""
  nodes: [Mention]!

  """
  A list of edges which contains the `Mention` and cursor to aid in pagination.
  """
  edges: [MentionsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Mention` you could get from the connection."""
  totalCount: Int!
}

type Mention implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  userId: UUID!
  mentionableType: String
  mentionableId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!

  """Reads a single `User` that is related to this `Mention`."""
  userByUserId: User
}

"""A `Mention` edge in the connection."""
type MentionsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Mention` at the end of the edge."""
  node: Mention
}

"""Methods to use when ordering `Mention`."""
enum MentionsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  MENTIONABLE_TYPE_ASC
  MENTIONABLE_TYPE_DESC
  MENTIONABLE_ID_ASC
  MENTIONABLE_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Mention` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input MentionCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `mentionableType` field."""
  mentionableType: String

  """Checks for equality with the object’s `mentionableId` field."""
  mentionableId: UUID

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A `AccountUser` edge in the connection."""
type AccountUsersEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `AccountUser` at the end of the edge."""
  node: AccountUser
}

"""A connection to a list of `ActiveStorageAttachment` values."""
type ActiveStorageAttachmentsConnection {
  """A list of `ActiveStorageAttachment` objects."""
  nodes: [ActiveStorageAttachment]!

  """
  A list of edges which contains the `ActiveStorageAttachment` and cursor to aid in pagination.
  """
  edges: [ActiveStorageAttachmentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ActiveStorageAttachment` you could get from the connection.
  """
  totalCount: Int!
}

type ActiveStorageAttachment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  name: String!
  recordType: String!
  blobId: BigInt!
  createdAt: Datetime!
  recordId: UUID!

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageAttachment`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob
}

type ActiveStorageBlob implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  key: String!
  filename: String!
  contentType: String
  metadata: String
  serviceName: String!
  byteSize: BigInt!
  checksum: String
  createdAt: Datetime!

  """
  Reads and enables pagination through a set of `ActiveStorageAttachment`.
  """
  activeStorageAttachmentsByBlobId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActiveStorageAttachment`."""
    orderBy: [ActiveStorageAttachmentsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActiveStorageAttachmentCondition
  ): ActiveStorageAttachmentsConnection!

  """
  Reads and enables pagination through a set of `ActiveStorageVariantRecord`.
  """
  activeStorageVariantRecordsByBlobId(
    """Only read the first `n` values of the set."""
    first: Int

    """Only read the last `n` values of the set."""
    last: Int

    """
    Skip the first `n` values from our `after` cursor, an alternative to cursor
    based pagination. May not be used with `last`.
    """
    offset: Int

    """Read all values in the set before (above) this cursor."""
    before: Cursor

    """Read all values in the set after (below) this cursor."""
    after: Cursor

    """The method to use when ordering `ActiveStorageVariantRecord`."""
    orderBy: [ActiveStorageVariantRecordsOrderBy!] = [PRIMARY_KEY_ASC]

    """
    A condition to be used in determining which values should be returned by the collection.
    """
    condition: ActiveStorageVariantRecordCondition
  ): ActiveStorageVariantRecordsConnection!
}

"""Methods to use when ordering `ActiveStorageAttachment`."""
enum ActiveStorageAttachmentsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  NAME_ASC
  NAME_DESC
  RECORD_TYPE_ASC
  RECORD_TYPE_DESC
  BLOB_ID_ASC
  BLOB_ID_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  RECORD_ID_ASC
  RECORD_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ActiveStorageAttachment` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input ActiveStorageAttachmentCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `recordType` field."""
  recordType: String

  """Checks for equality with the object’s `blobId` field."""
  blobId: BigInt

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `recordId` field."""
  recordId: UUID
}

"""A connection to a list of `ActiveStorageVariantRecord` values."""
type ActiveStorageVariantRecordsConnection {
  """A list of `ActiveStorageVariantRecord` objects."""
  nodes: [ActiveStorageVariantRecord]!

  """
  A list of edges which contains the `ActiveStorageVariantRecord` and cursor to aid in pagination.
  """
  edges: [ActiveStorageVariantRecordsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ActiveStorageVariantRecord` you could get from the connection.
  """
  totalCount: Int!
}

type ActiveStorageVariantRecord implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  blobId: BigInt!
  variationDigest: String!

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageVariantRecord`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob
}

"""A `ActiveStorageVariantRecord` edge in the connection."""
type ActiveStorageVariantRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ActiveStorageVariantRecord` at the end of the edge."""
  node: ActiveStorageVariantRecord
}

"""Methods to use when ordering `ActiveStorageVariantRecord`."""
enum ActiveStorageVariantRecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  BLOB_ID_ASC
  BLOB_ID_DESC
  VARIATION_DIGEST_ASC
  VARIATION_DIGEST_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ActiveStorageVariantRecord` object types. All
fields are tested for equality and combined with a logical ‘and.’
"""
input ActiveStorageVariantRecordCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `blobId` field."""
  blobId: BigInt

  """Checks for equality with the object’s `variationDigest` field."""
  variationDigest: String
}

"""A `ActiveStorageAttachment` edge in the connection."""
type ActiveStorageAttachmentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ActiveStorageAttachment` at the end of the edge."""
  node: ActiveStorageAttachment
}

"""A connection to a list of `ActiveStorageBlob` values."""
type ActiveStorageBlobsConnection {
  """A list of `ActiveStorageBlob` objects."""
  nodes: [ActiveStorageBlob]!

  """
  A list of edges which contains the `ActiveStorageBlob` and cursor to aid in pagination.
  """
  edges: [ActiveStorageBlobsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ActiveStorageBlob` you could get from the connection.
  """
  totalCount: Int!
}

"""A `ActiveStorageBlob` edge in the connection."""
type ActiveStorageBlobsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ActiveStorageBlob` at the end of the edge."""
  node: ActiveStorageBlob
}

"""Methods to use when ordering `ActiveStorageBlob`."""
enum ActiveStorageBlobsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  KEY_ASC
  KEY_DESC
  FILENAME_ASC
  FILENAME_DESC
  CONTENT_TYPE_ASC
  CONTENT_TYPE_DESC
  METADATA_ASC
  METADATA_DESC
  SERVICE_NAME_ASC
  SERVICE_NAME_DESC
  BYTE_SIZE_ASC
  BYTE_SIZE_DESC
  CHECKSUM_ASC
  CHECKSUM_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ActiveStorageBlob` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input ActiveStorageBlobCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `key` field."""
  key: String

  """Checks for equality with the object’s `filename` field."""
  filename: String

  """Checks for equality with the object’s `contentType` field."""
  contentType: String

  """Checks for equality with the object’s `metadata` field."""
  metadata: String

  """Checks for equality with the object’s `serviceName` field."""
  serviceName: String

  """Checks for equality with the object’s `byteSize` field."""
  byteSize: BigInt

  """Checks for equality with the object’s `checksum` field."""
  checksum: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime
}

"""A connection to a list of `ArInternalMetadatum` values."""
type ArInternalMetadataConnection {
  """A list of `ArInternalMetadatum` objects."""
  nodes: [ArInternalMetadatum]!

  """
  A list of edges which contains the `ArInternalMetadatum` and cursor to aid in pagination.
  """
  edges: [ArInternalMetadataEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `ArInternalMetadatum` you could get from the connection.
  """
  totalCount: Int!
}

type ArInternalMetadatum implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  key: String!
  value: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""A `ArInternalMetadatum` edge in the connection."""
type ArInternalMetadataEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `ArInternalMetadatum` at the end of the edge."""
  node: ArInternalMetadatum
}

"""Methods to use when ordering `ArInternalMetadatum`."""
enum ArInternalMetadataOrderBy {
  NATURAL
  KEY_ASC
  KEY_DESC
  VALUE_ASC
  VALUE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `ArInternalMetadatum` object types. All fields
are tested for equality and combined with a logical ‘and.’
"""
input ArInternalMetadatumCondition {
  """Checks for equality with the object’s `key` field."""
  key: String

  """Checks for equality with the object’s `value` field."""
  value: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `Comment` values."""
type CommentsConnection {
  """A list of `Comment` objects."""
  nodes: [Comment]!

  """
  A list of edges which contains the `Comment` and cursor to aid in pagination.
  """
  edges: [CommentsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Comment` you could get from the connection."""
  totalCount: Int!
}

type Comment implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  text: String
  createdAt: Datetime!
  updatedAt: Datetime!
  page: Int
  name: String
  id: UUID!
  commentThreadId: UUID
  userId: UUID
  textJson: JSON
  isDemo: Boolean
}

"""A `Comment` edge in the connection."""
type CommentsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Comment` at the end of the edge."""
  node: Comment
}

"""Methods to use when ordering `Comment`."""
enum CommentsOrderBy {
  NATURAL
  TEXT_ASC
  TEXT_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PAGE_ASC
  PAGE_DESC
  NAME_ASC
  NAME_DESC
  ID_ASC
  ID_DESC
  COMMENT_THREAD_ID_ASC
  COMMENT_THREAD_ID_DESC
  USER_ID_ASC
  USER_ID_DESC
  TEXT_JSON_ASC
  TEXT_JSON_DESC
  IS_DEMO_ASC
  IS_DEMO_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Comment` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input CommentCondition {
  """Checks for equality with the object’s `text` field."""
  text: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `page` field."""
  page: Int

  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `commentThreadId` field."""
  commentThreadId: UUID

  """Checks for equality with the object’s `userId` field."""
  userId: UUID

  """Checks for equality with the object’s `textJson` field."""
  textJson: JSON

  """Checks for equality with the object’s `isDemo` field."""
  isDemo: Boolean
}

"""A connection to a list of `FigmaPage` values."""
type FigmaPagesConnection {
  """A list of `FigmaPage` objects."""
  nodes: [FigmaPage]!

  """
  A list of edges which contains the `FigmaPage` and cursor to aid in pagination.
  """
  edges: [FigmaPagesEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `FigmaPage` you could get from the connection."""
  totalCount: Int!
}

type FigmaPage implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  frames: JSON
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""A `FigmaPage` edge in the connection."""
type FigmaPagesEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `FigmaPage` at the end of the edge."""
  node: FigmaPage
}

"""Methods to use when ordering `FigmaPage`."""
enum FigmaPagesOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  FRAMES_ASC
  FRAMES_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `FigmaPage` object types. All fields are tested
for equality and combined with a logical ‘and.’
"""
input FigmaPageCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `frames` field."""
  frames: JSON

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime
}

"""A connection to a list of `PaymentErrorRecord` values."""
type PaymentErrorRecordsConnection {
  """A list of `PaymentErrorRecord` objects."""
  nodes: [PaymentErrorRecord]!

  """
  A list of edges which contains the `PaymentErrorRecord` and cursor to aid in pagination.
  """
  edges: [PaymentErrorRecordsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `PaymentErrorRecord` you could get from the connection.
  """
  totalCount: Int!
}

type PaymentErrorRecord implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: BigInt!
  message: String
  createdAt: Datetime!
  updatedAt: Datetime!
  accountId: UUID!
}

"""A `PaymentErrorRecord` edge in the connection."""
type PaymentErrorRecordsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `PaymentErrorRecord` at the end of the edge."""
  node: PaymentErrorRecord
}

"""Methods to use when ordering `PaymentErrorRecord`."""
enum PaymentErrorRecordsOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  MESSAGE_ASC
  MESSAGE_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ACCOUNT_ID_ASC
  ACCOUNT_ID_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `PaymentErrorRecord` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input PaymentErrorRecordCondition {
  """Checks for equality with the object’s `id` field."""
  id: BigInt

  """Checks for equality with the object’s `message` field."""
  message: String

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `accountId` field."""
  accountId: UUID
}

"""A connection to a list of `Plan` values."""
type PlansConnection {
  """A list of `Plan` objects."""
  nodes: [Plan]!

  """
  A list of edges which contains the `Plan` and cursor to aid in pagination.
  """
  edges: [PlansEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Plan` you could get from the connection."""
  totalCount: Int!
}

"""A `Plan` edge in the connection."""
type PlansEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Plan` at the end of the edge."""
  node: Plan
}

"""Methods to use when ordering `Plan`."""
enum PlansOrderBy {
  NATURAL
  NAME_ASC
  NAME_DESC
  SLUG_ASC
  SLUG_DESC
  PERIOD_ASC
  PERIOD_DESC
  PRICE_CENTS_ASC
  PRICE_CENTS_DESC
  STRIPE_ID_ASC
  STRIPE_ID_DESC
  TRIAL_LENGTH_ASC
  TRIAL_LENGTH_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  ID_ASC
  ID_DESC
  PER_SEAT_STRIPE_ID_ASC
  PER_SEAT_STRIPE_ID_DESC
  SEATS_INCLUDED_ASC
  SEATS_INCLUDED_DESC
  PER_SEAT_PRICE_CENTS_ASC
  PER_SEAT_PRICE_CENTS_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Plan` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input PlanCondition {
  """Checks for equality with the object’s `name` field."""
  name: String

  """Checks for equality with the object’s `slug` field."""
  slug: String

  """Checks for equality with the object’s `period` field."""
  period: String

  """Checks for equality with the object’s `priceCents` field."""
  priceCents: Int

  """Checks for equality with the object’s `stripeId` field."""
  stripeId: String

  """Checks for equality with the object’s `trialLength` field."""
  trialLength: Int

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `perSeatStripeId` field."""
  perSeatStripeId: String

  """Checks for equality with the object’s `seatsIncluded` field."""
  seatsIncluded: Int

  """Checks for equality with the object’s `perSeatPriceCents` field."""
  perSeatPriceCents: Int
}

"""A connection to a list of `SchemaMigration` values."""
type SchemaMigrationsConnection {
  """A list of `SchemaMigration` objects."""
  nodes: [SchemaMigration]!

  """
  A list of edges which contains the `SchemaMigration` and cursor to aid in pagination.
  """
  edges: [SchemaMigrationsEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """
  The count of *all* `SchemaMigration` you could get from the connection.
  """
  totalCount: Int!
}

type SchemaMigration implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  version: String!
}

"""A `SchemaMigration` edge in the connection."""
type SchemaMigrationsEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `SchemaMigration` at the end of the edge."""
  node: SchemaMigration
}

"""Methods to use when ordering `SchemaMigration`."""
enum SchemaMigrationsOrderBy {
  NATURAL
  VERSION_ASC
  VERSION_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `SchemaMigration` object types. All fields are
tested for equality and combined with a logical ‘and.’
"""
input SchemaMigrationCondition {
  """Checks for equality with the object’s `version` field."""
  version: String
}

"""A connection to a list of `Todo` values."""
type TodosConnection {
  """A list of `Todo` objects."""
  nodes: [Todo]!

  """
  A list of edges which contains the `Todo` and cursor to aid in pagination.
  """
  edges: [TodosEdge!]!

  """Information to aid in pagination."""
  pageInfo: PageInfo!

  """The count of *all* `Todo` you could get from the connection."""
  totalCount: Int!
}

type Todo implements Node {
  """
  A globally unique identifier. Can be used in various places throughout the system to identify this single value.
  """
  nodeId: ID!
  id: UUID!
  text: String!
  position: Int!
  resolved: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  todoableId: UUID
  todoableType: String
}

"""A `Todo` edge in the connection."""
type TodosEdge {
  """A cursor for use in pagination."""
  cursor: Cursor

  """The `Todo` at the end of the edge."""
  node: Todo
}

"""Methods to use when ordering `Todo`."""
enum TodosOrderBy {
  NATURAL
  ID_ASC
  ID_DESC
  TEXT_ASC
  TEXT_DESC
  POSITION_ASC
  POSITION_DESC
  RESOLVED_ASC
  RESOLVED_DESC
  CREATED_AT_ASC
  CREATED_AT_DESC
  UPDATED_AT_ASC
  UPDATED_AT_DESC
  TODOABLE_ID_ASC
  TODOABLE_ID_DESC
  TODOABLE_TYPE_ASC
  TODOABLE_TYPE_DESC
  PRIMARY_KEY_ASC
  PRIMARY_KEY_DESC
}

"""
A condition to be used against `Todo` object types. All fields are tested for equality and combined with a logical ‘and.’
"""
input TodoCondition {
  """Checks for equality with the object’s `id` field."""
  id: UUID

  """Checks for equality with the object’s `text` field."""
  text: String

  """Checks for equality with the object’s `position` field."""
  position: Int

  """Checks for equality with the object’s `resolved` field."""
  resolved: Boolean

  """Checks for equality with the object’s `createdAt` field."""
  createdAt: Datetime

  """Checks for equality with the object’s `updatedAt` field."""
  updatedAt: Datetime

  """Checks for equality with the object’s `todoableId` field."""
  todoableId: UUID

  """Checks for equality with the object’s `todoableType` field."""
  todoableType: String
}

"""
The root mutation type which contains root level fields which mutate data.
"""
type Mutation {
  """Creates a single `AccountUser`."""
  createAccountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAccountUserInput!
  ): CreateAccountUserPayload

  """Creates a single `Account`."""
  createAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateAccountInput!
  ): CreateAccountPayload

  """Creates a single `ActiveStorageAttachment`."""
  createActiveStorageAttachment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateActiveStorageAttachmentInput!
  ): CreateActiveStorageAttachmentPayload

  """Creates a single `ActiveStorageBlob`."""
  createActiveStorageBlob(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateActiveStorageBlobInput!
  ): CreateActiveStorageBlobPayload

  """Creates a single `ActiveStorageVariantRecord`."""
  createActiveStorageVariantRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateActiveStorageVariantRecordInput!
  ): CreateActiveStorageVariantRecordPayload

  """Creates a single `ArInternalMetadatum`."""
  createArInternalMetadatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateArInternalMetadatumInput!
  ): CreateArInternalMetadatumPayload

  """Creates a single `CommentThread`."""
  createCommentThread(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCommentThreadInput!
  ): CreateCommentThreadPayload

  """Creates a single `Comment`."""
  createComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateCommentInput!
  ): CreateCommentPayload

  """Creates a single `ContactUser`."""
  createContactUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateContactUserInput!
  ): CreateContactUserPayload

  """Creates a single `ConversationUser`."""
  createConversationUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateConversationUserInput!
  ): CreateConversationUserPayload

  """Creates a single `Conversation`."""
  createConversation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateConversationInput!
  ): CreateConversationPayload

  """Creates a single `DocumentUser`."""
  createDocumentUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDocumentUserInput!
  ): CreateDocumentUserPayload

  """Creates a single `Document`."""
  createDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateDocumentInput!
  ): CreateDocumentPayload

  """Creates a single `Email`."""
  createEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateEmailInput!
  ): CreateEmailPayload

  """Creates a single `FigmaPage`."""
  createFigmaPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateFigmaPageInput!
  ): CreateFigmaPagePayload

  """Creates a single `Invoice`."""
  createInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateInvoiceInput!
  ): CreateInvoicePayload

  """Creates a single `Item`."""
  createItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateItemInput!
  ): CreateItemPayload

  """Creates a single `Lane`."""
  createLane(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateLaneInput!
  ): CreateLanePayload

  """Creates a single `Mention`."""
  createMention(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMentionInput!
  ): CreateMentionPayload

  """Creates a single `MessageFile`."""
  createMessageFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMessageFileInput!
  ): CreateMessageFilePayload

  """Creates a single `MessageUser`."""
  createMessageUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMessageUserInput!
  ): CreateMessageUserPayload

  """Creates a single `Message`."""
  createMessage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateMessageInput!
  ): CreateMessagePayload

  """Creates a single `Notification`."""
  createNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateNotificationInput!
  ): CreateNotificationPayload

  """Creates a single `PaymentErrorRecord`."""
  createPaymentErrorRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePaymentErrorRecordInput!
  ): CreatePaymentErrorRecordPayload

  """Creates a single `PaymentMethod`."""
  createPaymentMethod(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePaymentMethodInput!
  ): CreatePaymentMethodPayload

  """Creates a single `Plan`."""
  createPlan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreatePlanInput!
  ): CreatePlanPayload

  """Creates a single `ProjectUser`."""
  createProjectUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectUserInput!
  ): CreateProjectUserPayload

  """Creates a single `Project`."""
  createProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateProjectInput!
  ): CreateProjectPayload

  """Creates a single `Reaction`."""
  createReaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateReactionInput!
  ): CreateReactionPayload

  """Creates a single `Recording`."""
  createRecording(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateRecordingInput!
  ): CreateRecordingPayload

  """Creates a single `SchemaMigration`."""
  createSchemaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSchemaMigrationInput!
  ): CreateSchemaMigrationPayload

  """Creates a single `Sequence`."""
  createSequence(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSequenceInput!
  ): CreateSequencePayload

  """Creates a single `SiteFile`."""
  createSiteFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSiteFileInput!
  ): CreateSiteFilePayload

  """Creates a single `StorageFolder`."""
  createStorageFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStorageFolderInput!
  ): CreateStorageFolderPayload

  """Creates a single `Stroke`."""
  createStroke(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateStrokeInput!
  ): CreateStrokePayload

  """Creates a single `Subscription`."""
  createSubscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSubscriptionInput!
  ): CreateSubscriptionPayload

  """Creates a single `Suggestion`."""
  createSuggestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateSuggestionInput!
  ): CreateSuggestionPayload

  """Creates a single `Todo`."""
  createTodo(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTodoInput!
  ): CreateTodoPayload

  """Creates a single `Transcription`."""
  createTranscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateTranscriptionInput!
  ): CreateTranscriptionPayload

  """Creates a single `User`."""
  createUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateUserInput!
  ): CreateUserPayload

  """Creates a single `Version`."""
  createVersion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateVersionInput!
  ): CreateVersionPayload

  """Creates a single `WorkspaceUser`."""
  createWorkspaceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWorkspaceUserInput!
  ): CreateWorkspaceUserPayload

  """Creates a single `Workspace`."""
  createWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: CreateWorkspaceInput!
  ): CreateWorkspacePayload

  """
  Updates a single `AccountUser` using its globally unique id and a patch.
  """
  updateAccountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountUserInput!
  ): UpdateAccountUserPayload

  """Updates a single `AccountUser` using a unique key and a patch."""
  updateAccountUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountUserByIdInput!
  ): UpdateAccountUserPayload

  """Updates a single `Account` using its globally unique id and a patch."""
  updateAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountInput!
  ): UpdateAccountPayload

  """Updates a single `Account` using a unique key and a patch."""
  updateAccountById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateAccountByIdInput!
  ): UpdateAccountPayload

  """
  Updates a single `ActiveStorageAttachment` using its globally unique id and a patch.
  """
  updateActiveStorageAttachment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageAttachmentInput!
  ): UpdateActiveStorageAttachmentPayload

  """
  Updates a single `ActiveStorageAttachment` using a unique key and a patch.
  """
  updateActiveStorageAttachmentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageAttachmentByIdInput!
  ): UpdateActiveStorageAttachmentPayload

  """
  Updates a single `ActiveStorageBlob` using its globally unique id and a patch.
  """
  updateActiveStorageBlob(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageBlobInput!
  ): UpdateActiveStorageBlobPayload

  """Updates a single `ActiveStorageBlob` using a unique key and a patch."""
  updateActiveStorageBlobById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageBlobByIdInput!
  ): UpdateActiveStorageBlobPayload

  """
  Updates a single `ActiveStorageVariantRecord` using its globally unique id and a patch.
  """
  updateActiveStorageVariantRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageVariantRecordInput!
  ): UpdateActiveStorageVariantRecordPayload

  """
  Updates a single `ActiveStorageVariantRecord` using a unique key and a patch.
  """
  updateActiveStorageVariantRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateActiveStorageVariantRecordByIdInput!
  ): UpdateActiveStorageVariantRecordPayload

  """
  Updates a single `ArInternalMetadatum` using its globally unique id and a patch.
  """
  updateArInternalMetadatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArInternalMetadatumInput!
  ): UpdateArInternalMetadatumPayload

  """Updates a single `ArInternalMetadatum` using a unique key and a patch."""
  updateArInternalMetadatumByKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateArInternalMetadatumByKeyInput!
  ): UpdateArInternalMetadatumPayload

  """
  Updates a single `CommentThread` using its globally unique id and a patch.
  """
  updateCommentThread(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentThreadInput!
  ): UpdateCommentThreadPayload

  """Updates a single `CommentThread` using a unique key and a patch."""
  updateCommentThreadById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentThreadByIdInput!
  ): UpdateCommentThreadPayload

  """Updates a single `Comment` using its globally unique id and a patch."""
  updateComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentInput!
  ): UpdateCommentPayload

  """Updates a single `Comment` using a unique key and a patch."""
  updateCommentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateCommentByIdInput!
  ): UpdateCommentPayload

  """
  Updates a single `ContactUser` using its globally unique id and a patch.
  """
  updateContactUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContactUserInput!
  ): UpdateContactUserPayload

  """Updates a single `ContactUser` using a unique key and a patch."""
  updateContactUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateContactUserByIdInput!
  ): UpdateContactUserPayload

  """
  Updates a single `ConversationUser` using its globally unique id and a patch.
  """
  updateConversationUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConversationUserInput!
  ): UpdateConversationUserPayload

  """Updates a single `ConversationUser` using a unique key and a patch."""
  updateConversationUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConversationUserByIdInput!
  ): UpdateConversationUserPayload

  """
  Updates a single `Conversation` using its globally unique id and a patch.
  """
  updateConversation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConversationInput!
  ): UpdateConversationPayload

  """Updates a single `Conversation` using a unique key and a patch."""
  updateConversationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateConversationByIdInput!
  ): UpdateConversationPayload

  """
  Updates a single `DocumentUser` using its globally unique id and a patch.
  """
  updateDocumentUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDocumentUserInput!
  ): UpdateDocumentUserPayload

  """Updates a single `DocumentUser` using a unique key and a patch."""
  updateDocumentUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDocumentUserByIdInput!
  ): UpdateDocumentUserPayload

  """Updates a single `Document` using its globally unique id and a patch."""
  updateDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDocumentInput!
  ): UpdateDocumentPayload

  """Updates a single `Document` using a unique key and a patch."""
  updateDocumentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateDocumentByIdInput!
  ): UpdateDocumentPayload

  """Updates a single `Email` using its globally unique id and a patch."""
  updateEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEmailInput!
  ): UpdateEmailPayload

  """Updates a single `Email` using a unique key and a patch."""
  updateEmailById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateEmailByIdInput!
  ): UpdateEmailPayload

  """Updates a single `FigmaPage` using its globally unique id and a patch."""
  updateFigmaPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFigmaPageInput!
  ): UpdateFigmaPagePayload

  """Updates a single `FigmaPage` using a unique key and a patch."""
  updateFigmaPageById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateFigmaPageByIdInput!
  ): UpdateFigmaPagePayload

  """Updates a single `Invoice` using its globally unique id and a patch."""
  updateInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvoiceInput!
  ): UpdateInvoicePayload

  """Updates a single `Invoice` using a unique key and a patch."""
  updateInvoiceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateInvoiceByIdInput!
  ): UpdateInvoicePayload

  """Updates a single `Item` using its globally unique id and a patch."""
  updateItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateItemInput!
  ): UpdateItemPayload

  """Updates a single `Item` using a unique key and a patch."""
  updateItemById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateItemByIdInput!
  ): UpdateItemPayload

  """Updates a single `Lane` using its globally unique id and a patch."""
  updateLane(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLaneInput!
  ): UpdateLanePayload

  """Updates a single `Lane` using a unique key and a patch."""
  updateLaneById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateLaneByIdInput!
  ): UpdateLanePayload

  """Updates a single `Mention` using its globally unique id and a patch."""
  updateMention(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMentionInput!
  ): UpdateMentionPayload

  """Updates a single `Mention` using a unique key and a patch."""
  updateMentionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMentionByIdInput!
  ): UpdateMentionPayload

  """
  Updates a single `MessageFile` using its globally unique id and a patch.
  """
  updateMessageFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageFileInput!
  ): UpdateMessageFilePayload

  """Updates a single `MessageFile` using a unique key and a patch."""
  updateMessageFileById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageFileByIdInput!
  ): UpdateMessageFilePayload

  """
  Updates a single `MessageUser` using its globally unique id and a patch.
  """
  updateMessageUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageUserInput!
  ): UpdateMessageUserPayload

  """Updates a single `MessageUser` using a unique key and a patch."""
  updateMessageUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageUserByIdInput!
  ): UpdateMessageUserPayload

  """Updates a single `Message` using its globally unique id and a patch."""
  updateMessage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageInput!
  ): UpdateMessagePayload

  """Updates a single `Message` using a unique key and a patch."""
  updateMessageById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateMessageByIdInput!
  ): UpdateMessagePayload

  """
  Updates a single `Notification` using its globally unique id and a patch.
  """
  updateNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationInput!
  ): UpdateNotificationPayload

  """Updates a single `Notification` using a unique key and a patch."""
  updateNotificationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateNotificationByIdInput!
  ): UpdateNotificationPayload

  """
  Updates a single `PaymentErrorRecord` using its globally unique id and a patch.
  """
  updatePaymentErrorRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentErrorRecordInput!
  ): UpdatePaymentErrorRecordPayload

  """Updates a single `PaymentErrorRecord` using a unique key and a patch."""
  updatePaymentErrorRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentErrorRecordByIdInput!
  ): UpdatePaymentErrorRecordPayload

  """
  Updates a single `PaymentMethod` using its globally unique id and a patch.
  """
  updatePaymentMethod(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentMethodInput!
  ): UpdatePaymentMethodPayload

  """Updates a single `PaymentMethod` using a unique key and a patch."""
  updatePaymentMethodById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePaymentMethodByIdInput!
  ): UpdatePaymentMethodPayload

  """Updates a single `Plan` using its globally unique id and a patch."""
  updatePlan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlanInput!
  ): UpdatePlanPayload

  """Updates a single `Plan` using a unique key and a patch."""
  updatePlanById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdatePlanByIdInput!
  ): UpdatePlanPayload

  """
  Updates a single `ProjectUser` using its globally unique id and a patch.
  """
  updateProjectUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectUserInput!
  ): UpdateProjectUserPayload

  """Updates a single `ProjectUser` using a unique key and a patch."""
  updateProjectUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectUserByIdInput!
  ): UpdateProjectUserPayload

  """Updates a single `Project` using its globally unique id and a patch."""
  updateProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectInput!
  ): UpdateProjectPayload

  """Updates a single `Project` using a unique key and a patch."""
  updateProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateProjectByIdInput!
  ): UpdateProjectPayload

  """Updates a single `Reaction` using its globally unique id and a patch."""
  updateReaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReactionInput!
  ): UpdateReactionPayload

  """Updates a single `Reaction` using a unique key and a patch."""
  updateReactionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateReactionByIdInput!
  ): UpdateReactionPayload

  """Updates a single `Recording` using its globally unique id and a patch."""
  updateRecording(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRecordingInput!
  ): UpdateRecordingPayload

  """Updates a single `Recording` using a unique key and a patch."""
  updateRecordingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateRecordingByIdInput!
  ): UpdateRecordingPayload

  """
  Updates a single `SchemaMigration` using its globally unique id and a patch.
  """
  updateSchemaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSchemaMigrationInput!
  ): UpdateSchemaMigrationPayload

  """Updates a single `SchemaMigration` using a unique key and a patch."""
  updateSchemaMigrationByVersion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSchemaMigrationByVersionInput!
  ): UpdateSchemaMigrationPayload

  """Updates a single `Sequence` using its globally unique id and a patch."""
  updateSequence(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSequenceInput!
  ): UpdateSequencePayload

  """Updates a single `Sequence` using a unique key and a patch."""
  updateSequenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSequenceByIdInput!
  ): UpdateSequencePayload

  """Updates a single `SiteFile` using its globally unique id and a patch."""
  updateSiteFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSiteFileInput!
  ): UpdateSiteFilePayload

  """Updates a single `SiteFile` using a unique key and a patch."""
  updateSiteFileById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSiteFileByIdInput!
  ): UpdateSiteFilePayload

  """
  Updates a single `StorageFolder` using its globally unique id and a patch.
  """
  updateStorageFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStorageFolderInput!
  ): UpdateStorageFolderPayload

  """Updates a single `StorageFolder` using a unique key and a patch."""
  updateStorageFolderById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStorageFolderByIdInput!
  ): UpdateStorageFolderPayload

  """Updates a single `Stroke` using its globally unique id and a patch."""
  updateStroke(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStrokeInput!
  ): UpdateStrokePayload

  """Updates a single `Stroke` using a unique key and a patch."""
  updateStrokeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateStrokeByIdInput!
  ): UpdateStrokePayload

  """
  Updates a single `Subscription` using its globally unique id and a patch.
  """
  updateSubscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSubscriptionInput!
  ): UpdateSubscriptionPayload

  """Updates a single `Subscription` using a unique key and a patch."""
  updateSubscriptionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSubscriptionByIdInput!
  ): UpdateSubscriptionPayload

  """
  Updates a single `Suggestion` using its globally unique id and a patch.
  """
  updateSuggestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSuggestionInput!
  ): UpdateSuggestionPayload

  """Updates a single `Suggestion` using a unique key and a patch."""
  updateSuggestionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateSuggestionByIdInput!
  ): UpdateSuggestionPayload

  """Updates a single `Todo` using its globally unique id and a patch."""
  updateTodo(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTodoInput!
  ): UpdateTodoPayload

  """Updates a single `Todo` using a unique key and a patch."""
  updateTodoById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTodoByIdInput!
  ): UpdateTodoPayload

  """
  Updates a single `Transcription` using its globally unique id and a patch.
  """
  updateTranscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTranscriptionInput!
  ): UpdateTranscriptionPayload

  """Updates a single `Transcription` using a unique key and a patch."""
  updateTranscriptionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateTranscriptionByIdInput!
  ): UpdateTranscriptionPayload

  """Updates a single `User` using its globally unique id and a patch."""
  updateUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserInput!
  ): UpdateUserPayload

  """Updates a single `User` using a unique key and a patch."""
  updateUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateUserByIdInput!
  ): UpdateUserPayload

  """Updates a single `Version` using its globally unique id and a patch."""
  updateVersion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVersionInput!
  ): UpdateVersionPayload

  """Updates a single `Version` using a unique key and a patch."""
  updateVersionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateVersionByIdInput!
  ): UpdateVersionPayload

  """
  Updates a single `WorkspaceUser` using its globally unique id and a patch.
  """
  updateWorkspaceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceUserInput!
  ): UpdateWorkspaceUserPayload

  """Updates a single `WorkspaceUser` using a unique key and a patch."""
  updateWorkspaceUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceUserByIdInput!
  ): UpdateWorkspaceUserPayload

  """Updates a single `Workspace` using its globally unique id and a patch."""
  updateWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceInput!
  ): UpdateWorkspacePayload

  """Updates a single `Workspace` using a unique key and a patch."""
  updateWorkspaceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: UpdateWorkspaceByIdInput!
  ): UpdateWorkspacePayload

  """Deletes a single `AccountUser` using its globally unique id."""
  deleteAccountUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountUserInput!
  ): DeleteAccountUserPayload

  """Deletes a single `AccountUser` using a unique key."""
  deleteAccountUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountUserByIdInput!
  ): DeleteAccountUserPayload

  """Deletes a single `Account` using its globally unique id."""
  deleteAccount(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountInput!
  ): DeleteAccountPayload

  """Deletes a single `Account` using a unique key."""
  deleteAccountById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteAccountByIdInput!
  ): DeleteAccountPayload

  """
  Deletes a single `ActiveStorageAttachment` using its globally unique id.
  """
  deleteActiveStorageAttachment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageAttachmentInput!
  ): DeleteActiveStorageAttachmentPayload

  """Deletes a single `ActiveStorageAttachment` using a unique key."""
  deleteActiveStorageAttachmentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageAttachmentByIdInput!
  ): DeleteActiveStorageAttachmentPayload

  """Deletes a single `ActiveStorageBlob` using its globally unique id."""
  deleteActiveStorageBlob(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageBlobInput!
  ): DeleteActiveStorageBlobPayload

  """Deletes a single `ActiveStorageBlob` using a unique key."""
  deleteActiveStorageBlobById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageBlobByIdInput!
  ): DeleteActiveStorageBlobPayload

  """
  Deletes a single `ActiveStorageVariantRecord` using its globally unique id.
  """
  deleteActiveStorageVariantRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageVariantRecordInput!
  ): DeleteActiveStorageVariantRecordPayload

  """Deletes a single `ActiveStorageVariantRecord` using a unique key."""
  deleteActiveStorageVariantRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteActiveStorageVariantRecordByIdInput!
  ): DeleteActiveStorageVariantRecordPayload

  """Deletes a single `ArInternalMetadatum` using its globally unique id."""
  deleteArInternalMetadatum(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArInternalMetadatumInput!
  ): DeleteArInternalMetadatumPayload

  """Deletes a single `ArInternalMetadatum` using a unique key."""
  deleteArInternalMetadatumByKey(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteArInternalMetadatumByKeyInput!
  ): DeleteArInternalMetadatumPayload

  """Deletes a single `CommentThread` using its globally unique id."""
  deleteCommentThread(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentThreadInput!
  ): DeleteCommentThreadPayload

  """Deletes a single `CommentThread` using a unique key."""
  deleteCommentThreadById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentThreadByIdInput!
  ): DeleteCommentThreadPayload

  """Deletes a single `Comment` using its globally unique id."""
  deleteComment(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentInput!
  ): DeleteCommentPayload

  """Deletes a single `Comment` using a unique key."""
  deleteCommentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteCommentByIdInput!
  ): DeleteCommentPayload

  """Deletes a single `ContactUser` using its globally unique id."""
  deleteContactUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContactUserInput!
  ): DeleteContactUserPayload

  """Deletes a single `ContactUser` using a unique key."""
  deleteContactUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteContactUserByIdInput!
  ): DeleteContactUserPayload

  """Deletes a single `ConversationUser` using its globally unique id."""
  deleteConversationUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConversationUserInput!
  ): DeleteConversationUserPayload

  """Deletes a single `ConversationUser` using a unique key."""
  deleteConversationUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConversationUserByIdInput!
  ): DeleteConversationUserPayload

  """Deletes a single `Conversation` using its globally unique id."""
  deleteConversation(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConversationInput!
  ): DeleteConversationPayload

  """Deletes a single `Conversation` using a unique key."""
  deleteConversationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteConversationByIdInput!
  ): DeleteConversationPayload

  """Deletes a single `DocumentUser` using its globally unique id."""
  deleteDocumentUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDocumentUserInput!
  ): DeleteDocumentUserPayload

  """Deletes a single `DocumentUser` using a unique key."""
  deleteDocumentUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDocumentUserByIdInput!
  ): DeleteDocumentUserPayload

  """Deletes a single `Document` using its globally unique id."""
  deleteDocument(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDocumentInput!
  ): DeleteDocumentPayload

  """Deletes a single `Document` using a unique key."""
  deleteDocumentById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteDocumentByIdInput!
  ): DeleteDocumentPayload

  """Deletes a single `Email` using its globally unique id."""
  deleteEmail(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEmailInput!
  ): DeleteEmailPayload

  """Deletes a single `Email` using a unique key."""
  deleteEmailById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteEmailByIdInput!
  ): DeleteEmailPayload

  """Deletes a single `FigmaPage` using its globally unique id."""
  deleteFigmaPage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFigmaPageInput!
  ): DeleteFigmaPagePayload

  """Deletes a single `FigmaPage` using a unique key."""
  deleteFigmaPageById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteFigmaPageByIdInput!
  ): DeleteFigmaPagePayload

  """Deletes a single `Invoice` using its globally unique id."""
  deleteInvoice(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvoiceInput!
  ): DeleteInvoicePayload

  """Deletes a single `Invoice` using a unique key."""
  deleteInvoiceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteInvoiceByIdInput!
  ): DeleteInvoicePayload

  """Deletes a single `Item` using its globally unique id."""
  deleteItem(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteItemInput!
  ): DeleteItemPayload

  """Deletes a single `Item` using a unique key."""
  deleteItemById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteItemByIdInput!
  ): DeleteItemPayload

  """Deletes a single `Lane` using its globally unique id."""
  deleteLane(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLaneInput!
  ): DeleteLanePayload

  """Deletes a single `Lane` using a unique key."""
  deleteLaneById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteLaneByIdInput!
  ): DeleteLanePayload

  """Deletes a single `Mention` using its globally unique id."""
  deleteMention(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMentionInput!
  ): DeleteMentionPayload

  """Deletes a single `Mention` using a unique key."""
  deleteMentionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMentionByIdInput!
  ): DeleteMentionPayload

  """Deletes a single `MessageFile` using its globally unique id."""
  deleteMessageFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageFileInput!
  ): DeleteMessageFilePayload

  """Deletes a single `MessageFile` using a unique key."""
  deleteMessageFileById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageFileByIdInput!
  ): DeleteMessageFilePayload

  """Deletes a single `MessageUser` using its globally unique id."""
  deleteMessageUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageUserInput!
  ): DeleteMessageUserPayload

  """Deletes a single `MessageUser` using a unique key."""
  deleteMessageUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageUserByIdInput!
  ): DeleteMessageUserPayload

  """Deletes a single `Message` using its globally unique id."""
  deleteMessage(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageInput!
  ): DeleteMessagePayload

  """Deletes a single `Message` using a unique key."""
  deleteMessageById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteMessageByIdInput!
  ): DeleteMessagePayload

  """Deletes a single `Notification` using its globally unique id."""
  deleteNotification(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationInput!
  ): DeleteNotificationPayload

  """Deletes a single `Notification` using a unique key."""
  deleteNotificationById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteNotificationByIdInput!
  ): DeleteNotificationPayload

  """Deletes a single `PaymentErrorRecord` using its globally unique id."""
  deletePaymentErrorRecord(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentErrorRecordInput!
  ): DeletePaymentErrorRecordPayload

  """Deletes a single `PaymentErrorRecord` using a unique key."""
  deletePaymentErrorRecordById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentErrorRecordByIdInput!
  ): DeletePaymentErrorRecordPayload

  """Deletes a single `PaymentMethod` using its globally unique id."""
  deletePaymentMethod(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentMethodInput!
  ): DeletePaymentMethodPayload

  """Deletes a single `PaymentMethod` using a unique key."""
  deletePaymentMethodById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePaymentMethodByIdInput!
  ): DeletePaymentMethodPayload

  """Deletes a single `Plan` using its globally unique id."""
  deletePlan(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlanInput!
  ): DeletePlanPayload

  """Deletes a single `Plan` using a unique key."""
  deletePlanById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeletePlanByIdInput!
  ): DeletePlanPayload

  """Deletes a single `ProjectUser` using its globally unique id."""
  deleteProjectUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectUserInput!
  ): DeleteProjectUserPayload

  """Deletes a single `ProjectUser` using a unique key."""
  deleteProjectUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectUserByIdInput!
  ): DeleteProjectUserPayload

  """Deletes a single `Project` using its globally unique id."""
  deleteProject(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectInput!
  ): DeleteProjectPayload

  """Deletes a single `Project` using a unique key."""
  deleteProjectById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteProjectByIdInput!
  ): DeleteProjectPayload

  """Deletes a single `Reaction` using its globally unique id."""
  deleteReaction(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReactionInput!
  ): DeleteReactionPayload

  """Deletes a single `Reaction` using a unique key."""
  deleteReactionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteReactionByIdInput!
  ): DeleteReactionPayload

  """Deletes a single `Recording` using its globally unique id."""
  deleteRecording(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRecordingInput!
  ): DeleteRecordingPayload

  """Deletes a single `Recording` using a unique key."""
  deleteRecordingById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteRecordingByIdInput!
  ): DeleteRecordingPayload

  """Deletes a single `SchemaMigration` using its globally unique id."""
  deleteSchemaMigration(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSchemaMigrationInput!
  ): DeleteSchemaMigrationPayload

  """Deletes a single `SchemaMigration` using a unique key."""
  deleteSchemaMigrationByVersion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSchemaMigrationByVersionInput!
  ): DeleteSchemaMigrationPayload

  """Deletes a single `Sequence` using its globally unique id."""
  deleteSequence(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSequenceInput!
  ): DeleteSequencePayload

  """Deletes a single `Sequence` using a unique key."""
  deleteSequenceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSequenceByIdInput!
  ): DeleteSequencePayload

  """Deletes a single `SiteFile` using its globally unique id."""
  deleteSiteFile(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSiteFileInput!
  ): DeleteSiteFilePayload

  """Deletes a single `SiteFile` using a unique key."""
  deleteSiteFileById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSiteFileByIdInput!
  ): DeleteSiteFilePayload

  """Deletes a single `StorageFolder` using its globally unique id."""
  deleteStorageFolder(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStorageFolderInput!
  ): DeleteStorageFolderPayload

  """Deletes a single `StorageFolder` using a unique key."""
  deleteStorageFolderById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStorageFolderByIdInput!
  ): DeleteStorageFolderPayload

  """Deletes a single `Stroke` using its globally unique id."""
  deleteStroke(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStrokeInput!
  ): DeleteStrokePayload

  """Deletes a single `Stroke` using a unique key."""
  deleteStrokeById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteStrokeByIdInput!
  ): DeleteStrokePayload

  """Deletes a single `Subscription` using its globally unique id."""
  deleteSubscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSubscriptionInput!
  ): DeleteSubscriptionPayload

  """Deletes a single `Subscription` using a unique key."""
  deleteSubscriptionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSubscriptionByIdInput!
  ): DeleteSubscriptionPayload

  """Deletes a single `Suggestion` using its globally unique id."""
  deleteSuggestion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSuggestionInput!
  ): DeleteSuggestionPayload

  """Deletes a single `Suggestion` using a unique key."""
  deleteSuggestionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteSuggestionByIdInput!
  ): DeleteSuggestionPayload

  """Deletes a single `Todo` using its globally unique id."""
  deleteTodo(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTodoInput!
  ): DeleteTodoPayload

  """Deletes a single `Todo` using a unique key."""
  deleteTodoById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTodoByIdInput!
  ): DeleteTodoPayload

  """Deletes a single `Transcription` using its globally unique id."""
  deleteTranscription(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTranscriptionInput!
  ): DeleteTranscriptionPayload

  """Deletes a single `Transcription` using a unique key."""
  deleteTranscriptionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteTranscriptionByIdInput!
  ): DeleteTranscriptionPayload

  """Deletes a single `User` using its globally unique id."""
  deleteUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserInput!
  ): DeleteUserPayload

  """Deletes a single `User` using a unique key."""
  deleteUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteUserByIdInput!
  ): DeleteUserPayload

  """Deletes a single `Version` using its globally unique id."""
  deleteVersion(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVersionInput!
  ): DeleteVersionPayload

  """Deletes a single `Version` using a unique key."""
  deleteVersionById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteVersionByIdInput!
  ): DeleteVersionPayload

  """Deletes a single `WorkspaceUser` using its globally unique id."""
  deleteWorkspaceUser(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceUserInput!
  ): DeleteWorkspaceUserPayload

  """Deletes a single `WorkspaceUser` using a unique key."""
  deleteWorkspaceUserById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceUserByIdInput!
  ): DeleteWorkspaceUserPayload

  """Deletes a single `Workspace` using its globally unique id."""
  deleteWorkspace(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceInput!
  ): DeleteWorkspacePayload

  """Deletes a single `Workspace` using a unique key."""
  deleteWorkspaceById(
    """
    The exclusive input argument for this mutation. An object type, make sure to see documentation for this object’s fields.
    """
    input: DeleteWorkspaceByIdInput!
  ): DeleteWorkspacePayload
}

"""The output of our create `AccountUser` mutation."""
type CreateAccountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AccountUser` that was created by this mutation."""
  accountUser: AccountUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AccountUser`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `AccountUser`."""
  accountByAccountId: Account

  """An edge for our `AccountUser`. May be used by Relay 1."""
  accountUserEdge(
    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountUsersEdge
}

"""All input for the create `AccountUser` mutation."""
input CreateAccountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `AccountUser` to be created by this mutation."""
  accountUser: AccountUserInput!
}

"""An input for mutations affecting `AccountUser`"""
input AccountUserInput {
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int
  accountId: UUID!
  viewer: Boolean
  id: UUID
  position: Int
  showRecent: Boolean
  showShared: Boolean
  specificProjectsOnly: Boolean
  lastViewedSharedAt: Datetime
  lastViewedRecentAt: Datetime
  lastViewedFeedAt: Datetime
  slackEmail: String
  slackId: String
  sharedNotificationCount: Int
}

"""The output of our create `Account` mutation."""
type CreateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Account` that was created by this mutation."""
  account: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Account`."""
  userByOwnerId: User

  """Reads a single `Subscription` that is related to this `Account`."""
  subscriptionByCurrentSubscriptionId: Subscription

  """Reads a single `PaymentMethod` that is related to this `Account`."""
  paymentMethodByCurrentPaymentMethodId: PaymentMethod

  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the create `Account` mutation."""
input CreateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Account` to be created by this mutation."""
  account: AccountInput!
}

"""An input for mutations affecting `Account`"""
input AccountInput {
  name: String
  createdAt: Datetime!
  updatedAt: Datetime!
  ownerId: UUID!
  id: UUID
  stripeId: String
  photoProcessingStatus: Int
  photoProcessingError: String
  demo: Boolean
  hasUsedTrial: Boolean
  currentSubscriptionId: UUID
  currentPaymentMethodId: UUID
  offerDesktopNotifications: Boolean
  maxVersions: Int
  remainingVersions: Int
  maxInvites: Int
  remainingInvites: Int
  maxTeamInvites: Int
  remainingTeamInvites: Int
  inviteToken: UUID
  slackAccessToken: String
  slackIdentifier: String
  slackTeamName: String
  hasClients: Boolean
}

"""The output of our create `ActiveStorageAttachment` mutation."""
type CreateActiveStorageAttachmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageAttachment` that was created by this mutation."""
  activeStorageAttachment: ActiveStorageAttachment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageAttachment`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageAttachment`. May be used by Relay 1."""
  activeStorageAttachmentEdge(
    """The method to use when ordering `ActiveStorageAttachment`."""
    orderBy: [ActiveStorageAttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageAttachmentsEdge
}

"""All input for the create `ActiveStorageAttachment` mutation."""
input CreateActiveStorageAttachmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ActiveStorageAttachment` to be created by this mutation."""
  activeStorageAttachment: ActiveStorageAttachmentInput!
}

"""An input for mutations affecting `ActiveStorageAttachment`"""
input ActiveStorageAttachmentInput {
  id: BigInt
  name: String!
  recordType: String!
  blobId: BigInt!
  createdAt: Datetime!
  recordId: UUID!
}

"""The output of our create `ActiveStorageBlob` mutation."""
type CreateActiveStorageBlobPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageBlob` that was created by this mutation."""
  activeStorageBlob: ActiveStorageBlob

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ActiveStorageBlob`. May be used by Relay 1."""
  activeStorageBlobEdge(
    """The method to use when ordering `ActiveStorageBlob`."""
    orderBy: [ActiveStorageBlobsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageBlobsEdge
}

"""All input for the create `ActiveStorageBlob` mutation."""
input CreateActiveStorageBlobInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ActiveStorageBlob` to be created by this mutation."""
  activeStorageBlob: ActiveStorageBlobInput!
}

"""An input for mutations affecting `ActiveStorageBlob`"""
input ActiveStorageBlobInput {
  id: BigInt
  key: String!
  filename: String!
  contentType: String
  metadata: String
  serviceName: String!
  byteSize: BigInt!
  checksum: String
  createdAt: Datetime!
}

"""The output of our create `ActiveStorageVariantRecord` mutation."""
type CreateActiveStorageVariantRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageVariantRecord` that was created by this mutation."""
  activeStorageVariantRecord: ActiveStorageVariantRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageVariantRecord`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageVariantRecord`. May be used by Relay 1."""
  activeStorageVariantRecordEdge(
    """The method to use when ordering `ActiveStorageVariantRecord`."""
    orderBy: [ActiveStorageVariantRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageVariantRecordsEdge
}

"""All input for the create `ActiveStorageVariantRecord` mutation."""
input CreateActiveStorageVariantRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ActiveStorageVariantRecord` to be created by this mutation."""
  activeStorageVariantRecord: ActiveStorageVariantRecordInput!
}

"""An input for mutations affecting `ActiveStorageVariantRecord`"""
input ActiveStorageVariantRecordInput {
  id: BigInt
  blobId: BigInt!
  variationDigest: String!
}

"""The output of our create `ArInternalMetadatum` mutation."""
type CreateArInternalMetadatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ArInternalMetadatum` that was created by this mutation."""
  arInternalMetadatum: ArInternalMetadatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ArInternalMetadatum`. May be used by Relay 1."""
  arInternalMetadatumEdge(
    """The method to use when ordering `ArInternalMetadatum`."""
    orderBy: [ArInternalMetadataOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArInternalMetadataEdge
}

"""All input for the create `ArInternalMetadatum` mutation."""
input CreateArInternalMetadatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ArInternalMetadatum` to be created by this mutation."""
  arInternalMetadatum: ArInternalMetadatumInput!
}

"""An input for mutations affecting `ArInternalMetadatum`"""
input ArInternalMetadatumInput {
  key: String!
  value: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `CommentThread` mutation."""
type CreateCommentThreadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommentThread` that was created by this mutation."""
  commentThread: CommentThread

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `CommentThread`."""
  versionByVersionId: Version

  """An edge for our `CommentThread`. May be used by Relay 1."""
  commentThreadEdge(
    """The method to use when ordering `CommentThread`."""
    orderBy: [CommentThreadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentThreadsEdge
}

"""All input for the create `CommentThread` mutation."""
input CreateCommentThreadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `CommentThread` to be created by this mutation."""
  commentThread: CommentThreadInput!
}

"""An input for mutations affecting `CommentThread`"""
input CommentThreadInput {
  positionX: Int
  positionY: Int
  page: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID
  versionId: UUID
  screenWidth: Int
  resolved: Boolean
  position: Int
  elementId: String
  positionPercentageX: Float
  positionPercentageY: Float
}

"""The output of our create `Comment` mutation."""
type CreateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was created by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the create `Comment` mutation."""
input CreateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Comment` to be created by this mutation."""
  comment: CommentInput!
}

"""An input for mutations affecting `Comment`"""
input CommentInput {
  text: String
  createdAt: Datetime!
  updatedAt: Datetime!
  page: Int
  name: String
  id: UUID
  commentThreadId: UUID
  userId: UUID
  textJson: JSON
  isDemo: Boolean
}

"""The output of our create `ContactUser` mutation."""
type CreateContactUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContactUser` that was created by this mutation."""
  contactUser: ContactUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ContactUser`."""
  userByContactId: User

  """Reads a single `User` that is related to this `ContactUser`."""
  userByUserId: User

  """An edge for our `ContactUser`. May be used by Relay 1."""
  contactUserEdge(
    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContactUsersEdge
}

"""All input for the create `ContactUser` mutation."""
input CreateContactUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ContactUser` to be created by this mutation."""
  contactUser: ContactUserInput!
}

"""An input for mutations affecting `ContactUser`"""
input ContactUserInput {
  id: BigInt
  contactId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `ConversationUser` mutation."""
type CreateConversationUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ConversationUser` that was created by this mutation."""
  conversationUser: ConversationUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Conversation` that is related to this `ConversationUser`.
  """
  conversationByConversationId: Conversation

  """Reads a single `User` that is related to this `ConversationUser`."""
  userByUserId: User

  """An edge for our `ConversationUser`. May be used by Relay 1."""
  conversationUserEdge(
    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationUsersEdge
}

"""All input for the create `ConversationUser` mutation."""
input CreateConversationUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ConversationUser` to be created by this mutation."""
  conversationUser: ConversationUserInput!
}

"""An input for mutations affecting `ConversationUser`"""
input ConversationUserInput {
  id: BigInt
  conversationId: UUID!
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int
  lastReadDiscussionAt: Datetime
  position: Int
  muted: Boolean
  visible: Boolean
  lastViewed: Datetime
  name: String!
}

"""The output of our create `Conversation` mutation."""
type CreateConversationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Conversation` that was created by this mutation."""
  conversation: Conversation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Conversation`."""
  accountByAccountId: Account

  """An edge for our `Conversation`. May be used by Relay 1."""
  conversationEdge(
    """The method to use when ordering `Conversation`."""
    orderBy: [ConversationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationsEdge
}

"""All input for the create `Conversation` mutation."""
input CreateConversationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Conversation` to be created by this mutation."""
  conversation: ConversationInput!
}

"""An input for mutations affecting `Conversation`"""
input ConversationInput {
  id: UUID
  accountId: UUID!
  slug: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `DocumentUser` mutation."""
type CreateDocumentUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DocumentUser` that was created by this mutation."""
  documentUser: DocumentUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByUserId: User

  """Reads a single `Document` that is related to this `DocumentUser`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByAssignerId: User

  """An edge for our `DocumentUser`. May be used by Relay 1."""
  documentUserEdge(
    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentUsersEdge
}

"""All input for the create `DocumentUser` mutation."""
input CreateDocumentUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `DocumentUser` to be created by this mutation."""
  documentUser: DocumentUserInput!
}

"""An input for mutations affecting `DocumentUser`"""
input DocumentUserInput {
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int
  lastViewed: Datetime
  documentId: UUID!
  lastReadDiscussionAt: Datetime
  guest: Boolean!
  id: UUID
  assigned: Boolean
  assignerId: UUID
  observer: Boolean
}

"""The output of our create `Document` mutation."""
type CreateDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Document` that was created by this mutation."""
  document: Document

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Document`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Lane` that is related to this `Document`."""
  laneByLaneId: Lane

  """Reads a single `User` that is related to this `Document`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `Document`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Document`."""
  projectByProjectId: Project

  """Reads a single `StorageFolder` that is related to this `Document`."""
  storageFolderByStorageFolderId: StorageFolder

  """An edge for our `Document`. May be used by Relay 1."""
  documentEdge(
    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentsEdge
}

"""All input for the create `Document` mutation."""
input CreateDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Document` to be created by this mutation."""
  document: DocumentInput!
}

"""An input for mutations affecting `Document`"""
input DocumentInput {
  name: String!
  slug: String!
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID
  figmaId: String
  figmaHash: String
  figmaName: String
  figmaKeep: Boolean
  figmaQuickHash: String
  workspaceId: UUID
  laneId: UUID!
  position: Int
  userId: UUID
  description: String
  figmaPageUuid: String
  globalAccess: Boolean
  archived: Boolean
  descriptionJson: JSON
  accountId: UUID!
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
  isDemo: Boolean
  figmaSortedIds: String
  projectId: UUID
  stored: Boolean
  storageFolderId: UUID
}

"""The output of our create `Email` mutation."""
type CreateEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Email` that was created by this mutation."""
  email: Email

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Email`."""
  versionByVersionId: Version

  """Reads a single `Document` that is related to this `Email`."""
  documentByDocumentId: Document

  """Reads a single `Workspace` that is related to this `Email`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Email`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Email`."""
  projectByProjectId: Project

  """Reads a single `Conversation` that is related to this `Email`."""
  conversationByConversationId: Conversation

  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the create `Email` mutation."""
input CreateEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Email` to be created by this mutation."""
  email: EmailInput!
}

"""An input for mutations affecting `Email`"""
input EmailInput {
  id: BigInt
  category: Int
  sequenceId: BigInt
  createdAt: Datetime!
  updatedAt: Datetime!
  templateId: String
  data: JSON
  apiResponseData: JSON
  state: Int
  to: String!
  userId: UUID
  versionId: UUID
  documentId: UUID
  emailableType: String
  emailableId: UUID
  workspaceId: UUID
  accountId: UUID
  service: Int
  projectId: UUID
  replyToName: String
  replyToEmail: String
  conversationId: UUID
}

"""The output of our create `FigmaPage` mutation."""
type CreateFigmaPagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `FigmaPage` that was created by this mutation."""
  figmaPage: FigmaPage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `FigmaPage`. May be used by Relay 1."""
  figmaPageEdge(
    """The method to use when ordering `FigmaPage`."""
    orderBy: [FigmaPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FigmaPagesEdge
}

"""All input for the create `FigmaPage` mutation."""
input CreateFigmaPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `FigmaPage` to be created by this mutation."""
  figmaPage: FigmaPageInput!
}

"""An input for mutations affecting `FigmaPage`"""
input FigmaPageInput {
  id: UUID
  frames: JSON
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `Invoice` mutation."""
type CreateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was created by this mutation."""
  invoice: Invoice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Invoice`."""
  accountByAccountId: Account

  """Reads a single `Subscription` that is related to this `Invoice`."""
  subscriptionBySubscriptionId: Subscription

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the create `Invoice` mutation."""
input CreateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Invoice` to be created by this mutation."""
  invoice: InvoiceInput!
}

"""An input for mutations affecting `Invoice`"""
input InvoiceInput {
  id: BigInt
  createdAt: Datetime!
  updatedAt: Datetime!
  accountId: UUID!
  lineItems: JSON!
  priceCents: Int!
  currency: String!
  paymentMethodId: UUID
  subscriptionId: UUID
  stripeId: String!
  status: Int!
  pdfLink: String
  planName: String
}

"""The output of our create `Item` mutation."""
type CreateItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Item` that was created by this mutation."""
  item: Item

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Item`."""
  versionByVersionId: Version

  """An edge for our `Item`. May be used by Relay 1."""
  itemEdge(
    """The method to use when ordering `Item`."""
    orderBy: [ItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ItemsEdge
}

"""All input for the create `Item` mutation."""
input CreateItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Item` to be created by this mutation."""
  item: ItemInput!
}

"""An input for mutations affecting `Item`"""
input ItemInput {
  type: String
  pages: Int
  width: Int
  height: Int
  contentType: String
  url: String
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int!
  id: UUID
  versionId: UUID
  processingStatus: Int
  processingErrorReason: String
  positionX: Int
  positionY: Int
  pageWidth: Int
  figmaHash: String
  figmaQuickHash: String
}

"""The output of our create `Lane` mutation."""
type CreateLanePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lane` that was created by this mutation."""
  lane: Lane

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Lane`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Lane`."""
  accountByAccountId: Account

  """An edge for our `Lane`. May be used by Relay 1."""
  laneEdge(
    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanesEdge
}

"""All input for the create `Lane` mutation."""
input CreateLaneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Lane` to be created by this mutation."""
  lane: LaneInput!
}

"""An input for mutations affecting `Lane`"""
input LaneInput {
  id: UUID
  workspaceId: UUID
  name: String!
  label: String
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int
  accountId: UUID!
}

"""The output of our create `Mention` mutation."""
type CreateMentionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mention` that was created by this mutation."""
  mention: Mention

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Mention`."""
  userByUserId: User

  """An edge for our `Mention`. May be used by Relay 1."""
  mentionEdge(
    """The method to use when ordering `Mention`."""
    orderBy: [MentionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MentionsEdge
}

"""All input for the create `Mention` mutation."""
input CreateMentionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Mention` to be created by this mutation."""
  mention: MentionInput!
}

"""An input for mutations affecting `Mention`"""
input MentionInput {
  id: UUID
  userId: UUID!
  mentionableType: String
  mentionableId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `MessageFile` mutation."""
type CreateMessageFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageFile` that was created by this mutation."""
  messageFile: MessageFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageFile`."""
  messageByMessageId: Message

  """An edge for our `MessageFile`. May be used by Relay 1."""
  messageFileEdge(
    """The method to use when ordering `MessageFile`."""
    orderBy: [MessageFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageFilesEdge
}

"""All input for the create `MessageFile` mutation."""
input CreateMessageFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MessageFile` to be created by this mutation."""
  messageFile: MessageFileInput!
}

"""An input for mutations affecting `MessageFile`"""
input MessageFileInput {
  id: UUID
  messageId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
  thumbnailProcessingStatus: Int
  thumbnailProcessingError: String
  name: String!
}

"""The output of our create `MessageUser` mutation."""
type CreateMessageUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageUser` that was created by this mutation."""
  messageUser: MessageUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageUser`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `MessageUser`."""
  userByUserId: User

  """An edge for our `MessageUser`. May be used by Relay 1."""
  messageUserEdge(
    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageUsersEdge
}

"""All input for the create `MessageUser` mutation."""
input CreateMessageUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `MessageUser` to be created by this mutation."""
  messageUser: MessageUserInput!
}

"""An input for mutations affecting `MessageUser`"""
input MessageUserInput {
  id: BigInt
  messageId: UUID!
  userId: UUID!
  lastReadDiscussionAt: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `Message` mutation."""
type CreateMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Message` that was created by this mutation."""
  message: Message

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Message`."""
  userByUserId: User

  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the create `Message` mutation."""
input CreateMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Message` to be created by this mutation."""
  message: MessageInput!
}

"""An input for mutations affecting `Message`"""
input MessageInput {
  id: UUID
  userId: UUID!
  text: String
  messagableId: UUID
  messagableType: String
  createdAt: Datetime!
  updatedAt: Datetime!
  category: Int!
  threadableId: UUID
  threadableType: String
  replyCount: Int
  textJson: JSON
  isDemo: Boolean
}

"""The output of our create `Notification` mutation."""
type CreateNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Notification` that was created by this mutation."""
  notification: Notification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Notification`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Notification`."""
  userByOriginatorId: User

  """Reads a single `Version` that is related to this `Notification`."""
  versionByVersionId: Version

  """Reads a single `Account` that is related to this `Notification`."""
  accountByAccountId: Account

  """An edge for our `Notification`. May be used by Relay 1."""
  notificationEdge(
    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""All input for the create `Notification` mutation."""
input CreateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Notification` to be created by this mutation."""
  notification: NotificationInput!
}

"""An input for mutations affecting `Notification`"""
input NotificationInput {
  category: Int!
  read: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!
  userId: UUID!
  id: UUID
  originatorId: UUID!
  page: Int
  versionId: UUID
  notifiableType: String!
  notifiableId: UUID!
  screenWidth: Int
  notifiablePageType: String!
  notifiablePageId: UUID!
  accountId: UUID!
  dropdownPage: Int
}

"""The output of our create `PaymentErrorRecord` mutation."""
type CreatePaymentErrorRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentErrorRecord` that was created by this mutation."""
  paymentErrorRecord: PaymentErrorRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PaymentErrorRecord`. May be used by Relay 1."""
  paymentErrorRecordEdge(
    """The method to use when ordering `PaymentErrorRecord`."""
    orderBy: [PaymentErrorRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentErrorRecordsEdge
}

"""All input for the create `PaymentErrorRecord` mutation."""
input CreatePaymentErrorRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PaymentErrorRecord` to be created by this mutation."""
  paymentErrorRecord: PaymentErrorRecordInput!
}

"""An input for mutations affecting `PaymentErrorRecord`"""
input PaymentErrorRecordInput {
  id: BigInt
  message: String
  createdAt: Datetime!
  updatedAt: Datetime!
  accountId: UUID!
}

"""The output of our create `PaymentMethod` mutation."""
type CreatePaymentMethodPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentMethod` that was created by this mutation."""
  paymentMethod: PaymentMethod

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `PaymentMethod`."""
  accountByAccountId: Account

  """An edge for our `PaymentMethod`. May be used by Relay 1."""
  paymentMethodEdge(
    """The method to use when ordering `PaymentMethod`."""
    orderBy: [PaymentMethodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentMethodsEdge
}

"""All input for the create `PaymentMethod` mutation."""
input CreatePaymentMethodInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `PaymentMethod` to be created by this mutation."""
  paymentMethod: PaymentMethodInput!
}

"""An input for mutations affecting `PaymentMethod`"""
input PaymentMethodInput {
  accountId: UUID!
  stripeId: String!
  last4: String
  expMonth: Int
  expYear: Int
  country: String
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID
  brand: String
}

"""The output of our create `Plan` mutation."""
type CreatePlanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plan` that was created by this mutation."""
  plan: Plan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plan`. May be used by Relay 1."""
  planEdge(
    """The method to use when ordering `Plan`."""
    orderBy: [PlansOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlansEdge
}

"""All input for the create `Plan` mutation."""
input CreatePlanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Plan` to be created by this mutation."""
  plan: PlanInput!
}

"""An input for mutations affecting `Plan`"""
input PlanInput {
  name: String!
  slug: String!
  period: String!
  priceCents: Int!
  stripeId: String!
  trialLength: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  id: UUID
  perSeatStripeId: String
  seatsIncluded: Int
  perSeatPriceCents: Int
}

"""The output of our create `ProjectUser` mutation."""
type CreateProjectUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectUser` that was created by this mutation."""
  projectUser: ProjectUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ProjectUser`."""
  userByUserId: User

  """Reads a single `Project` that is related to this `ProjectUser`."""
  projectByProjectId: Project

  """Reads a single `Account` that is related to this `ProjectUser`."""
  accountByAccountId: Account

  """An edge for our `ProjectUser`. May be used by Relay 1."""
  projectUserEdge(
    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectUsersEdge
}

"""All input for the create `ProjectUser` mutation."""
input CreateProjectUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `ProjectUser` to be created by this mutation."""
  projectUser: ProjectUserInput!
}

"""An input for mutations affecting `ProjectUser`"""
input ProjectUserInput {
  id: UUID
  userId: UUID!
  projectId: UUID!
  notificationCount: Int
  guest: Boolean!
  createdAt: Datetime!
  updatedAt: Datetime!
  position: Int
  accountId: UUID!
  specificWorkspacesOnly: Boolean
  workspaceBarOpen: Boolean
}

"""The output of our create `Project` mutation."""
type CreateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was created by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Project`."""
  accountByAccountId: Account

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the create `Project` mutation."""
input CreateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Project` to be created by this mutation."""
  project: ProjectInput!
}

"""An input for mutations affecting `Project`"""
input ProjectInput {
  id: UUID
  name: String
  accountId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  archived: Boolean
  globalAccess: Boolean
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
}

"""The output of our create `Reaction` mutation."""
type CreateReactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reaction` that was created by this mutation."""
  reaction: Reaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `Reaction`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `Reaction`."""
  userByUserId: User

  """An edge for our `Reaction`. May be used by Relay 1."""
  reactionEdge(
    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReactionsEdge
}

"""All input for the create `Reaction` mutation."""
input CreateReactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Reaction` to be created by this mutation."""
  reaction: ReactionInput!
}

"""An input for mutations affecting `Reaction`"""
input ReactionInput {
  id: UUID
  messageId: UUID!
  userId: UUID!
  text: String
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `Recording` mutation."""
type CreateRecordingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Recording` that was created by this mutation."""
  recording: Recording

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Recording`."""
  userByUserId: User

  """Reads a single `Version` that is related to this `Recording`."""
  versionByVersionId: Version

  """An edge for our `Recording`. May be used by Relay 1."""
  recordingEdge(
    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecordingsEdge
}

"""All input for the create `Recording` mutation."""
input CreateRecordingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Recording` to be created by this mutation."""
  recording: RecordingInput!
}

"""An input for mutations affecting `Recording`"""
input RecordingInput {
  createdAt: Datetime!
  updatedAt: Datetime!
  isIntro: Boolean
  reviewer: String
  slug: String
  userId: UUID!
  page: Int!
  id: UUID
  versionId: UUID
  thumbnailProcessingStatus: Int
  viewedBy: JSON
  isDemo: Boolean
}

"""The output of our create `SchemaMigration` mutation."""
type CreateSchemaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SchemaMigration` that was created by this mutation."""
  schemaMigration: SchemaMigration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `SchemaMigration`. May be used by Relay 1."""
  schemaMigrationEdge(
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchemaMigrationsEdge
}

"""All input for the create `SchemaMigration` mutation."""
input CreateSchemaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SchemaMigration` to be created by this mutation."""
  schemaMigration: SchemaMigrationInput!
}

"""An input for mutations affecting `SchemaMigration`"""
input SchemaMigrationInput {
  version: String!
}

"""The output of our create `Sequence` mutation."""
type CreateSequencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Sequence` that was created by this mutation."""
  sequence: Sequence

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Sequence`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Sequence`."""
  userBySenderId: User

  """An edge for our `Sequence`. May be used by Relay 1."""
  sequenceEdge(
    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SequencesEdge
}

"""All input for the create `Sequence` mutation."""
input CreateSequenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Sequence` to be created by this mutation."""
  sequence: SequenceInput!
}

"""An input for mutations affecting `Sequence`"""
input SequenceInput {
  id: BigInt
  createdAt: Datetime!
  updatedAt: Datetime!
  frequency: String!
  linkClicked: Boolean
  unsubscribed: Boolean
  emailsSent: Int
  lastSentAt: Datetime
  nextJobId: String
  cancelled: Boolean
  userId: UUID!
  senderId: UUID
  sequencableType: String!
  sequencableId: UUID
  message: String
  subject: String
}

"""The output of our create `SiteFile` mutation."""
type CreateSiteFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SiteFile` that was created by this mutation."""
  siteFile: SiteFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Item` that is related to this `SiteFile`."""
  itemByItemId: Item

  """An edge for our `SiteFile`. May be used by Relay 1."""
  siteFileEdge(
    """The method to use when ordering `SiteFile`."""
    orderBy: [SiteFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SiteFilesEdge
}

"""All input for the create `SiteFile` mutation."""
input CreateSiteFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `SiteFile` to be created by this mutation."""
  siteFile: SiteFileInput!
}

"""An input for mutations affecting `SiteFile`"""
input SiteFileInput {
  createdAt: Datetime!
  updatedAt: Datetime!
  filename: String
  itemId: UUID
  id: UUID
}

"""The output of our create `StorageFolder` mutation."""
type CreateStorageFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StorageFolder` that was created by this mutation."""
  storageFolder: StorageFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `StorageFolder`."""
  accountByAccountId: Account

  """
  Reads a single `StorageFolder` that is related to this `StorageFolder`.
  """
  storageFolderByParentId: StorageFolder

  """Reads a single `Project` that is related to this `StorageFolder`."""
  projectByProjectId: Project

  """An edge for our `StorageFolder`. May be used by Relay 1."""
  storageFolderEdge(
    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): StorageFoldersEdge
}

"""All input for the create `StorageFolder` mutation."""
input CreateStorageFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `StorageFolder` to be created by this mutation."""
  storageFolder: StorageFolderInput!
}

"""An input for mutations affecting `StorageFolder`"""
input StorageFolderInput {
  id: UUID
  name: String
  accountId: UUID!
  parentId: UUID
  projectId: UUID
  createdAt: Datetime!
  updatedAt: Datetime!
}

"""The output of our create `Stroke` mutation."""
type CreateStrokePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Stroke` that was created by this mutation."""
  stroke: Stroke

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Stroke`."""
  versionByVersionId: Version

  """An edge for our `Stroke`. May be used by Relay 1."""
  strokeEdge(
    """The method to use when ordering `Stroke`."""
    orderBy: [StrokesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StrokesEdge
}

"""All input for the create `Stroke` mutation."""
input CreateStrokeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Stroke` to be created by this mutation."""
  stroke: StrokeInput!
}

"""An input for mutations affecting `Stroke`"""
input StrokeInput {
  id: BigInt
  page: Int
  drawing: String
  createdAt: Datetime!
  updatedAt: Datetime!
  versionId: UUID
  screenWidth: Int
}

"""The output of our create `Subscription` mutation."""
type CreateSubscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Subscription` that was created by this mutation."""
  subscription: Subscription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Subscription`."""
  accountByAccountId: Account

  """Reads a single `Plan` that is related to this `Subscription`."""
  planByPlanId: Plan

  """An edge for our `Subscription`. May be used by Relay 1."""
  subscriptionEdge(
    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionsEdge
}

"""All input for the create `Subscription` mutation."""
input CreateSubscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Subscription` to be created by this mutation."""
  subscription: SubscriptionInput!
}

"""An input for mutations affecting `Subscription`"""
input SubscriptionInput {
  id: UUID
  accountId: UUID!
  planId: UUID!
  stripeId: String
  status: Int
  startAt: Datetime!
  trialStartAt: Datetime
  renewAt: Datetime
  endAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime!
  updatedAt: Datetime!
  items: JSON
}

"""The output of our create `Suggestion` mutation."""
type CreateSuggestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Suggestion` that was created by this mutation."""
  suggestion: Suggestion

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Transcription` that is related to this `Suggestion`."""
  transcriptionByTranscriptionId: Transcription

  """An edge for our `Suggestion`. May be used by Relay 1."""
  suggestionEdge(
    """The method to use when ordering `Suggestion`."""
    orderBy: [SuggestionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuggestionsEdge
}

"""All input for the create `Suggestion` mutation."""
input CreateSuggestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Suggestion` to be created by this mutation."""
  suggestion: SuggestionInput!
}

"""An input for mutations affecting `Suggestion`"""
input SuggestionInput {
  id: BigInt
  transcriptionId: BigInt!
  content: String
  createdAt: Datetime!
  updatedAt: Datetime!
  reviewed: Boolean
}

"""The output of our create `Todo` mutation."""
type CreateTodoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Todo` that was created by this mutation."""
  todo: Todo

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Todo`. May be used by Relay 1."""
  todoEdge(
    """The method to use when ordering `Todo`."""
    orderBy: [TodosOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodosEdge
}

"""All input for the create `Todo` mutation."""
input CreateTodoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Todo` to be created by this mutation."""
  todo: TodoInput!
}

"""An input for mutations affecting `Todo`"""
input TodoInput {
  id: UUID
  text: String!
  position: Int
  resolved: Boolean
  createdAt: Datetime!
  updatedAt: Datetime!
  todoableId: UUID
  todoableType: String
}

"""The output of our create `Transcription` mutation."""
type CreateTranscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transcription` that was created by this mutation."""
  transcription: Transcription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Recording` that is related to this `Transcription`."""
  recordingByRecordingId: Recording

  """An edge for our `Transcription`. May be used by Relay 1."""
  transcriptionEdge(
    """The method to use when ordering `Transcription`."""
    orderBy: [TranscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TranscriptionsEdge
}

"""All input for the create `Transcription` mutation."""
input CreateTranscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Transcription` to be created by this mutation."""
  transcription: TranscriptionInput!
}

"""An input for mutations affecting `Transcription`"""
input TranscriptionInput {
  id: BigInt
  jobName: String
  jobStatus: Int
  createdAt: Datetime!
  updatedAt: Datetime!
  recordingId: UUID
  content: String
}

"""The output of our create `User` mutation."""
type CreateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was created by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `User`."""
  accountByCurrentAccountId: Account

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the create `User` mutation."""
input CreateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `User` to be created by this mutation."""
  user: UserInput!
}

"""An input for mutations affecting `User`"""
input UserInput {
  email: String
  firstName: String
  lastName: String
  id: UUID
  photoProcessingStatus: Int
  photoProcessingError: String
  notificationCount: Int
  currentAccountId: UUID
  showSidebar: Boolean
  emailOnProductUpdates: Boolean
  emailOnMessages: Boolean
  emailOnFeedback: Boolean
  emailLimitToDaily: Boolean
  enableDesktopNotifications: Boolean
  color: String
  emailOnMentionsAndAssignments: Boolean
  hasUsedTrial: Boolean
  currentMic: String
  currentCamera: String
  showTextToolbars: Boolean
  emojiSkinTone: String
  penColor: String
  penSize: Float
  photoTemporary: String
  hasDesktopApp: Boolean
  offerDesktopApp: Boolean
  conversationsOpen: Boolean
  currentRoute: String
}

"""The output of our create `Version` mutation."""
type CreateVersionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Version` that was created by this mutation."""
  version: Version

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Document` that is related to this `Version`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `Version`."""
  userByUserId: User

  """An edge for our `Version`. May be used by Relay 1."""
  versionEdge(
    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VersionsEdge
}

"""All input for the create `Version` mutation."""
input CreateVersionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Version` to be created by this mutation."""
  version: VersionInput!
}

"""An input for mutations affecting `Version`"""
input VersionInput {
  slug: String
  createdAt: Datetime!
  updatedAt: Datetime!
  count: Int
  dimensions: JSON
  versionNumber: Int
  id: UUID
  documentId: UUID!
  thumbnailProcessingStatus: Int
  processingErrorReason: String
  firstFileIsImage: Boolean
  userId: UUID
  figmaLink: String
}

"""The output of our create `WorkspaceUser` mutation."""
type CreateWorkspaceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `WorkspaceUser` that was created by this mutation."""
  workspaceUser: WorkspaceUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `WorkspaceUser`."""
  userByUserId: User

  """Reads a single `Workspace` that is related to this `WorkspaceUser`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Project` that is related to this `WorkspaceUser`."""
  projectByProjectId: Project

  """An edge for our `WorkspaceUser`. May be used by Relay 1."""
  workspaceUserEdge(
    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspaceUsersEdge
}

"""All input for the create `WorkspaceUser` mutation."""
input CreateWorkspaceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `WorkspaceUser` to be created by this mutation."""
  workspaceUser: WorkspaceUserInput!
}

"""An input for mutations affecting `WorkspaceUser`"""
input WorkspaceUserInput {
  userId: UUID!
  createdAt: Datetime!
  updatedAt: Datetime!
  notificationCount: Int
  guest: Boolean!
  lastViewed: Datetime
  workspaceId: UUID!
  lastReadDiscussionAt: Datetime
  id: UUID
  position: Int
  projectId: UUID!
  muted: Boolean
}

"""The output of our create `Workspace` mutation."""
type CreateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was created by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjectId: Project

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the create `Workspace` mutation."""
input CreateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """The `Workspace` to be created by this mutation."""
  workspace: WorkspaceInput!
}

"""An input for mutations affecting `Workspace`"""
input WorkspaceInput {
  name: String
  createdAt: Datetime!
  updatedAt: Datetime!
  slug: String
  figmaDeletedIds: JSON
  category: Int!
  id: UUID
  projectId: UUID!
  archived: Boolean
  globalAccess: Boolean
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
}

"""The output of our update `AccountUser` mutation."""
type UpdateAccountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AccountUser` that was updated by this mutation."""
  accountUser: AccountUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AccountUser`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `AccountUser`."""
  accountByAccountId: Account

  """An edge for our `AccountUser`. May be used by Relay 1."""
  accountUserEdge(
    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountUsersEdge
}

"""All input for the `updateAccountUser` mutation."""
input UpdateAccountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AccountUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `AccountUser` being updated.
  """
  accountUserPatch: AccountUserPatch!
}

"""
Represents an update to a `AccountUser`. Fields that are set will be updated.
"""
input AccountUserPatch {
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  notificationCount: Int
  accountId: UUID
  viewer: Boolean
  id: UUID
  position: Int
  showRecent: Boolean
  showShared: Boolean
  specificProjectsOnly: Boolean
  lastViewedSharedAt: Datetime
  lastViewedRecentAt: Datetime
  lastViewedFeedAt: Datetime
  slackEmail: String
  slackId: String
  sharedNotificationCount: Int
}

"""All input for the `updateAccountUserById` mutation."""
input UpdateAccountUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `AccountUser` being updated.
  """
  accountUserPatch: AccountUserPatch!
  id: UUID!
}

"""The output of our update `Account` mutation."""
type UpdateAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Account` that was updated by this mutation."""
  account: Account

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Account`."""
  userByOwnerId: User

  """Reads a single `Subscription` that is related to this `Account`."""
  subscriptionByCurrentSubscriptionId: Subscription

  """Reads a single `PaymentMethod` that is related to this `Account`."""
  paymentMethodByCurrentPaymentMethodId: PaymentMethod

  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the `updateAccount` mutation."""
input UpdateAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  accountPatch: AccountPatch!
}

"""
Represents an update to a `Account`. Fields that are set will be updated.
"""
input AccountPatch {
  name: String
  createdAt: Datetime
  updatedAt: Datetime
  ownerId: UUID
  id: UUID
  stripeId: String
  photoProcessingStatus: Int
  photoProcessingError: String
  demo: Boolean
  hasUsedTrial: Boolean
  currentSubscriptionId: UUID
  currentPaymentMethodId: UUID
  offerDesktopNotifications: Boolean
  maxVersions: Int
  remainingVersions: Int
  maxInvites: Int
  remainingInvites: Int
  maxTeamInvites: Int
  remainingTeamInvites: Int
  inviteToken: UUID
  slackAccessToken: String
  slackIdentifier: String
  slackTeamName: String
  hasClients: Boolean
}

"""All input for the `updateAccountById` mutation."""
input UpdateAccountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Account` being updated.
  """
  accountPatch: AccountPatch!
  id: UUID!
}

"""The output of our update `ActiveStorageAttachment` mutation."""
type UpdateActiveStorageAttachmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageAttachment` that was updated by this mutation."""
  activeStorageAttachment: ActiveStorageAttachment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageAttachment`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageAttachment`. May be used by Relay 1."""
  activeStorageAttachmentEdge(
    """The method to use when ordering `ActiveStorageAttachment`."""
    orderBy: [ActiveStorageAttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageAttachmentsEdge
}

"""All input for the `updateActiveStorageAttachment` mutation."""
input UpdateActiveStorageAttachmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageAttachment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ActiveStorageAttachment` being updated.
  """
  activeStorageAttachmentPatch: ActiveStorageAttachmentPatch!
}

"""
Represents an update to a `ActiveStorageAttachment`. Fields that are set will be updated.
"""
input ActiveStorageAttachmentPatch {
  id: BigInt
  name: String
  recordType: String
  blobId: BigInt
  createdAt: Datetime
  recordId: UUID
}

"""All input for the `updateActiveStorageAttachmentById` mutation."""
input UpdateActiveStorageAttachmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ActiveStorageAttachment` being updated.
  """
  activeStorageAttachmentPatch: ActiveStorageAttachmentPatch!
  id: BigInt!
}

"""The output of our update `ActiveStorageBlob` mutation."""
type UpdateActiveStorageBlobPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageBlob` that was updated by this mutation."""
  activeStorageBlob: ActiveStorageBlob

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ActiveStorageBlob`. May be used by Relay 1."""
  activeStorageBlobEdge(
    """The method to use when ordering `ActiveStorageBlob`."""
    orderBy: [ActiveStorageBlobsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageBlobsEdge
}

"""All input for the `updateActiveStorageBlob` mutation."""
input UpdateActiveStorageBlobInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageBlob` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ActiveStorageBlob` being updated.
  """
  activeStorageBlobPatch: ActiveStorageBlobPatch!
}

"""
Represents an update to a `ActiveStorageBlob`. Fields that are set will be updated.
"""
input ActiveStorageBlobPatch {
  id: BigInt
  key: String
  filename: String
  contentType: String
  metadata: String
  serviceName: String
  byteSize: BigInt
  checksum: String
  createdAt: Datetime
}

"""All input for the `updateActiveStorageBlobById` mutation."""
input UpdateActiveStorageBlobByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ActiveStorageBlob` being updated.
  """
  activeStorageBlobPatch: ActiveStorageBlobPatch!
  id: BigInt!
}

"""The output of our update `ActiveStorageVariantRecord` mutation."""
type UpdateActiveStorageVariantRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageVariantRecord` that was updated by this mutation."""
  activeStorageVariantRecord: ActiveStorageVariantRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageVariantRecord`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageVariantRecord`. May be used by Relay 1."""
  activeStorageVariantRecordEdge(
    """The method to use when ordering `ActiveStorageVariantRecord`."""
    orderBy: [ActiveStorageVariantRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageVariantRecordsEdge
}

"""All input for the `updateActiveStorageVariantRecord` mutation."""
input UpdateActiveStorageVariantRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageVariantRecord` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ActiveStorageVariantRecord` being updated.
  """
  activeStorageVariantRecordPatch: ActiveStorageVariantRecordPatch!
}

"""
Represents an update to a `ActiveStorageVariantRecord`. Fields that are set will be updated.
"""
input ActiveStorageVariantRecordPatch {
  id: BigInt
  blobId: BigInt
  variationDigest: String
}

"""All input for the `updateActiveStorageVariantRecordById` mutation."""
input UpdateActiveStorageVariantRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ActiveStorageVariantRecord` being updated.
  """
  activeStorageVariantRecordPatch: ActiveStorageVariantRecordPatch!
  id: BigInt!
}

"""The output of our update `ArInternalMetadatum` mutation."""
type UpdateArInternalMetadatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ArInternalMetadatum` that was updated by this mutation."""
  arInternalMetadatum: ArInternalMetadatum

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ArInternalMetadatum`. May be used by Relay 1."""
  arInternalMetadatumEdge(
    """The method to use when ordering `ArInternalMetadatum`."""
    orderBy: [ArInternalMetadataOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArInternalMetadataEdge
}

"""All input for the `updateArInternalMetadatum` mutation."""
input UpdateArInternalMetadatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ArInternalMetadatum` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ArInternalMetadatum` being updated.
  """
  arInternalMetadatumPatch: ArInternalMetadatumPatch!
}

"""
Represents an update to a `ArInternalMetadatum`. Fields that are set will be updated.
"""
input ArInternalMetadatumPatch {
  key: String
  value: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateArInternalMetadatumByKey` mutation."""
input UpdateArInternalMetadatumByKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ArInternalMetadatum` being updated.
  """
  arInternalMetadatumPatch: ArInternalMetadatumPatch!
  key: String!
}

"""The output of our update `CommentThread` mutation."""
type UpdateCommentThreadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommentThread` that was updated by this mutation."""
  commentThread: CommentThread

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `CommentThread`."""
  versionByVersionId: Version

  """An edge for our `CommentThread`. May be used by Relay 1."""
  commentThreadEdge(
    """The method to use when ordering `CommentThread`."""
    orderBy: [CommentThreadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentThreadsEdge
}

"""All input for the `updateCommentThread` mutation."""
input UpdateCommentThreadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CommentThread` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `CommentThread` being updated.
  """
  commentThreadPatch: CommentThreadPatch!
}

"""
Represents an update to a `CommentThread`. Fields that are set will be updated.
"""
input CommentThreadPatch {
  positionX: Int
  positionY: Int
  page: Int
  createdAt: Datetime
  updatedAt: Datetime
  id: UUID
  versionId: UUID
  screenWidth: Int
  resolved: Boolean
  position: Int
  elementId: String
  positionPercentageX: Float
  positionPercentageY: Float
}

"""All input for the `updateCommentThreadById` mutation."""
input UpdateCommentThreadByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `CommentThread` being updated.
  """
  commentThreadPatch: CommentThreadPatch!
  id: UUID!
}

"""The output of our update `Comment` mutation."""
type UpdateCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was updated by this mutation."""
  comment: Comment

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `updateComment` mutation."""
input UpdateCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Comment` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Comment` being updated.
  """
  commentPatch: CommentPatch!
}

"""
Represents an update to a `Comment`. Fields that are set will be updated.
"""
input CommentPatch {
  text: String
  createdAt: Datetime
  updatedAt: Datetime
  page: Int
  name: String
  id: UUID
  commentThreadId: UUID
  userId: UUID
  textJson: JSON
  isDemo: Boolean
}

"""All input for the `updateCommentById` mutation."""
input UpdateCommentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Comment` being updated.
  """
  commentPatch: CommentPatch!
  id: UUID!
}

"""The output of our update `ContactUser` mutation."""
type UpdateContactUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContactUser` that was updated by this mutation."""
  contactUser: ContactUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ContactUser`."""
  userByContactId: User

  """Reads a single `User` that is related to this `ContactUser`."""
  userByUserId: User

  """An edge for our `ContactUser`. May be used by Relay 1."""
  contactUserEdge(
    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContactUsersEdge
}

"""All input for the `updateContactUser` mutation."""
input UpdateContactUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContactUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ContactUser` being updated.
  """
  contactUserPatch: ContactUserPatch!
}

"""
Represents an update to a `ContactUser`. Fields that are set will be updated.
"""
input ContactUserPatch {
  id: BigInt
  contactId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateContactUserById` mutation."""
input UpdateContactUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ContactUser` being updated.
  """
  contactUserPatch: ContactUserPatch!
  id: BigInt!
}

"""The output of our update `ConversationUser` mutation."""
type UpdateConversationUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ConversationUser` that was updated by this mutation."""
  conversationUser: ConversationUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Conversation` that is related to this `ConversationUser`.
  """
  conversationByConversationId: Conversation

  """Reads a single `User` that is related to this `ConversationUser`."""
  userByUserId: User

  """An edge for our `ConversationUser`. May be used by Relay 1."""
  conversationUserEdge(
    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationUsersEdge
}

"""All input for the `updateConversationUser` mutation."""
input UpdateConversationUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ConversationUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ConversationUser` being updated.
  """
  conversationUserPatch: ConversationUserPatch!
}

"""
Represents an update to a `ConversationUser`. Fields that are set will be updated.
"""
input ConversationUserPatch {
  id: BigInt
  conversationId: UUID
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  notificationCount: Int
  lastReadDiscussionAt: Datetime
  position: Int
  muted: Boolean
  visible: Boolean
  lastViewed: Datetime
  name: String
}

"""All input for the `updateConversationUserById` mutation."""
input UpdateConversationUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ConversationUser` being updated.
  """
  conversationUserPatch: ConversationUserPatch!
  id: BigInt!
}

"""The output of our update `Conversation` mutation."""
type UpdateConversationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Conversation` that was updated by this mutation."""
  conversation: Conversation

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Conversation`."""
  accountByAccountId: Account

  """An edge for our `Conversation`. May be used by Relay 1."""
  conversationEdge(
    """The method to use when ordering `Conversation`."""
    orderBy: [ConversationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationsEdge
}

"""All input for the `updateConversation` mutation."""
input UpdateConversationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Conversation` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Conversation` being updated.
  """
  conversationPatch: ConversationPatch!
}

"""
Represents an update to a `Conversation`. Fields that are set will be updated.
"""
input ConversationPatch {
  id: UUID
  accountId: UUID
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateConversationById` mutation."""
input UpdateConversationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Conversation` being updated.
  """
  conversationPatch: ConversationPatch!
  id: UUID!
}

"""The output of our update `DocumentUser` mutation."""
type UpdateDocumentUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DocumentUser` that was updated by this mutation."""
  documentUser: DocumentUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByUserId: User

  """Reads a single `Document` that is related to this `DocumentUser`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByAssignerId: User

  """An edge for our `DocumentUser`. May be used by Relay 1."""
  documentUserEdge(
    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentUsersEdge
}

"""All input for the `updateDocumentUser` mutation."""
input UpdateDocumentUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DocumentUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `DocumentUser` being updated.
  """
  documentUserPatch: DocumentUserPatch!
}

"""
Represents an update to a `DocumentUser`. Fields that are set will be updated.
"""
input DocumentUserPatch {
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  notificationCount: Int
  lastViewed: Datetime
  documentId: UUID
  lastReadDiscussionAt: Datetime
  guest: Boolean
  id: UUID
  assigned: Boolean
  assignerId: UUID
  observer: Boolean
}

"""All input for the `updateDocumentUserById` mutation."""
input UpdateDocumentUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `DocumentUser` being updated.
  """
  documentUserPatch: DocumentUserPatch!
  id: UUID!
}

"""The output of our update `Document` mutation."""
type UpdateDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Document` that was updated by this mutation."""
  document: Document

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Document`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Lane` that is related to this `Document`."""
  laneByLaneId: Lane

  """Reads a single `User` that is related to this `Document`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `Document`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Document`."""
  projectByProjectId: Project

  """Reads a single `StorageFolder` that is related to this `Document`."""
  storageFolderByStorageFolderId: StorageFolder

  """An edge for our `Document`. May be used by Relay 1."""
  documentEdge(
    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentsEdge
}

"""All input for the `updateDocument` mutation."""
input UpdateDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Document` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Document` being updated.
  """
  documentPatch: DocumentPatch!
}

"""
Represents an update to a `Document`. Fields that are set will be updated.
"""
input DocumentPatch {
  name: String
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
  id: UUID
  figmaId: String
  figmaHash: String
  figmaName: String
  figmaKeep: Boolean
  figmaQuickHash: String
  workspaceId: UUID
  laneId: UUID
  position: Int
  userId: UUID
  description: String
  figmaPageUuid: String
  globalAccess: Boolean
  archived: Boolean
  descriptionJson: JSON
  accountId: UUID
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
  isDemo: Boolean
  figmaSortedIds: String
  projectId: UUID
  stored: Boolean
  storageFolderId: UUID
}

"""All input for the `updateDocumentById` mutation."""
input UpdateDocumentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Document` being updated.
  """
  documentPatch: DocumentPatch!
  id: UUID!
}

"""The output of our update `Email` mutation."""
type UpdateEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Email` that was updated by this mutation."""
  email: Email

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Email`."""
  versionByVersionId: Version

  """Reads a single `Document` that is related to this `Email`."""
  documentByDocumentId: Document

  """Reads a single `Workspace` that is related to this `Email`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Email`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Email`."""
  projectByProjectId: Project

  """Reads a single `Conversation` that is related to this `Email`."""
  conversationByConversationId: Conversation

  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the `updateEmail` mutation."""
input UpdateEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Email` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Email` being updated.
  """
  emailPatch: EmailPatch!
}

"""
Represents an update to a `Email`. Fields that are set will be updated.
"""
input EmailPatch {
  id: BigInt
  category: Int
  sequenceId: BigInt
  createdAt: Datetime
  updatedAt: Datetime
  templateId: String
  data: JSON
  apiResponseData: JSON
  state: Int
  to: String
  userId: UUID
  versionId: UUID
  documentId: UUID
  emailableType: String
  emailableId: UUID
  workspaceId: UUID
  accountId: UUID
  service: Int
  projectId: UUID
  replyToName: String
  replyToEmail: String
  conversationId: UUID
}

"""All input for the `updateEmailById` mutation."""
input UpdateEmailByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Email` being updated.
  """
  emailPatch: EmailPatch!
  id: BigInt!
}

"""The output of our update `FigmaPage` mutation."""
type UpdateFigmaPagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `FigmaPage` that was updated by this mutation."""
  figmaPage: FigmaPage

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `FigmaPage`. May be used by Relay 1."""
  figmaPageEdge(
    """The method to use when ordering `FigmaPage`."""
    orderBy: [FigmaPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FigmaPagesEdge
}

"""All input for the `updateFigmaPage` mutation."""
input UpdateFigmaPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FigmaPage` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `FigmaPage` being updated.
  """
  figmaPagePatch: FigmaPagePatch!
}

"""
Represents an update to a `FigmaPage`. Fields that are set will be updated.
"""
input FigmaPagePatch {
  id: UUID
  frames: JSON
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateFigmaPageById` mutation."""
input UpdateFigmaPageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `FigmaPage` being updated.
  """
  figmaPagePatch: FigmaPagePatch!
  id: UUID!
}

"""The output of our update `Invoice` mutation."""
type UpdateInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was updated by this mutation."""
  invoice: Invoice

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Invoice`."""
  accountByAccountId: Account

  """Reads a single `Subscription` that is related to this `Invoice`."""
  subscriptionBySubscriptionId: Subscription

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `updateInvoice` mutation."""
input UpdateInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invoice` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Invoice` being updated.
  """
  invoicePatch: InvoicePatch!
}

"""
Represents an update to a `Invoice`. Fields that are set will be updated.
"""
input InvoicePatch {
  id: BigInt
  createdAt: Datetime
  updatedAt: Datetime
  accountId: UUID
  lineItems: JSON
  priceCents: Int
  currency: String
  paymentMethodId: UUID
  subscriptionId: UUID
  stripeId: String
  status: Int
  pdfLink: String
  planName: String
}

"""All input for the `updateInvoiceById` mutation."""
input UpdateInvoiceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Invoice` being updated.
  """
  invoicePatch: InvoicePatch!
  id: BigInt!
}

"""The output of our update `Item` mutation."""
type UpdateItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Item` that was updated by this mutation."""
  item: Item

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Item`."""
  versionByVersionId: Version

  """An edge for our `Item`. May be used by Relay 1."""
  itemEdge(
    """The method to use when ordering `Item`."""
    orderBy: [ItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ItemsEdge
}

"""All input for the `updateItem` mutation."""
input UpdateItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Item` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Item` being updated.
  """
  itemPatch: ItemPatch!
}

"""Represents an update to a `Item`. Fields that are set will be updated."""
input ItemPatch {
  type: String
  pages: Int
  width: Int
  height: Int
  contentType: String
  url: String
  createdAt: Datetime
  updatedAt: Datetime
  position: Int
  id: UUID
  versionId: UUID
  processingStatus: Int
  processingErrorReason: String
  positionX: Int
  positionY: Int
  pageWidth: Int
  figmaHash: String
  figmaQuickHash: String
}

"""All input for the `updateItemById` mutation."""
input UpdateItemByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Item` being updated.
  """
  itemPatch: ItemPatch!
  id: UUID!
}

"""The output of our update `Lane` mutation."""
type UpdateLanePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lane` that was updated by this mutation."""
  lane: Lane

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Lane`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Lane`."""
  accountByAccountId: Account

  """An edge for our `Lane`. May be used by Relay 1."""
  laneEdge(
    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanesEdge
}

"""All input for the `updateLane` mutation."""
input UpdateLaneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Lane` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Lane` being updated.
  """
  lanePatch: LanePatch!
}

"""Represents an update to a `Lane`. Fields that are set will be updated."""
input LanePatch {
  id: UUID
  workspaceId: UUID
  name: String
  label: String
  createdAt: Datetime
  updatedAt: Datetime
  position: Int
  accountId: UUID
}

"""All input for the `updateLaneById` mutation."""
input UpdateLaneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Lane` being updated.
  """
  lanePatch: LanePatch!
  id: UUID!
}

"""The output of our update `Mention` mutation."""
type UpdateMentionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mention` that was updated by this mutation."""
  mention: Mention

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Mention`."""
  userByUserId: User

  """An edge for our `Mention`. May be used by Relay 1."""
  mentionEdge(
    """The method to use when ordering `Mention`."""
    orderBy: [MentionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MentionsEdge
}

"""All input for the `updateMention` mutation."""
input UpdateMentionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Mention` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Mention` being updated.
  """
  mentionPatch: MentionPatch!
}

"""
Represents an update to a `Mention`. Fields that are set will be updated.
"""
input MentionPatch {
  id: UUID
  userId: UUID
  mentionableType: String
  mentionableId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateMentionById` mutation."""
input UpdateMentionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Mention` being updated.
  """
  mentionPatch: MentionPatch!
  id: UUID!
}

"""The output of our update `MessageFile` mutation."""
type UpdateMessageFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageFile` that was updated by this mutation."""
  messageFile: MessageFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageFile`."""
  messageByMessageId: Message

  """An edge for our `MessageFile`. May be used by Relay 1."""
  messageFileEdge(
    """The method to use when ordering `MessageFile`."""
    orderBy: [MessageFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageFilesEdge
}

"""All input for the `updateMessageFile` mutation."""
input UpdateMessageFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MessageFile` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `MessageFile` being updated.
  """
  messageFilePatch: MessageFilePatch!
}

"""
Represents an update to a `MessageFile`. Fields that are set will be updated.
"""
input MessageFilePatch {
  id: UUID
  messageId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  thumbnailProcessingStatus: Int
  thumbnailProcessingError: String
  name: String
}

"""All input for the `updateMessageFileById` mutation."""
input UpdateMessageFileByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MessageFile` being updated.
  """
  messageFilePatch: MessageFilePatch!
  id: UUID!
}

"""The output of our update `MessageUser` mutation."""
type UpdateMessageUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageUser` that was updated by this mutation."""
  messageUser: MessageUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageUser`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `MessageUser`."""
  userByUserId: User

  """An edge for our `MessageUser`. May be used by Relay 1."""
  messageUserEdge(
    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageUsersEdge
}

"""All input for the `updateMessageUser` mutation."""
input UpdateMessageUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MessageUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `MessageUser` being updated.
  """
  messageUserPatch: MessageUserPatch!
}

"""
Represents an update to a `MessageUser`. Fields that are set will be updated.
"""
input MessageUserPatch {
  id: BigInt
  messageId: UUID
  userId: UUID
  lastReadDiscussionAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateMessageUserById` mutation."""
input UpdateMessageUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `MessageUser` being updated.
  """
  messageUserPatch: MessageUserPatch!
  id: BigInt!
}

"""The output of our update `Message` mutation."""
type UpdateMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Message` that was updated by this mutation."""
  message: Message

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Message`."""
  userByUserId: User

  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the `updateMessage` mutation."""
input UpdateMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Message` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Message` being updated.
  """
  messagePatch: MessagePatch!
}

"""
Represents an update to a `Message`. Fields that are set will be updated.
"""
input MessagePatch {
  id: UUID
  userId: UUID
  text: String
  messagableId: UUID
  messagableType: String
  createdAt: Datetime
  updatedAt: Datetime
  category: Int
  threadableId: UUID
  threadableType: String
  replyCount: Int
  textJson: JSON
  isDemo: Boolean
}

"""All input for the `updateMessageById` mutation."""
input UpdateMessageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Message` being updated.
  """
  messagePatch: MessagePatch!
  id: UUID!
}

"""The output of our update `Notification` mutation."""
type UpdateNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Notification` that was updated by this mutation."""
  notification: Notification

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Notification`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Notification`."""
  userByOriginatorId: User

  """Reads a single `Version` that is related to this `Notification`."""
  versionByVersionId: Version

  """Reads a single `Account` that is related to this `Notification`."""
  accountByAccountId: Account

  """An edge for our `Notification`. May be used by Relay 1."""
  notificationEdge(
    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""All input for the `updateNotification` mutation."""
input UpdateNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  notificationPatch: NotificationPatch!
}

"""
Represents an update to a `Notification`. Fields that are set will be updated.
"""
input NotificationPatch {
  category: Int
  read: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  userId: UUID
  id: UUID
  originatorId: UUID
  page: Int
  versionId: UUID
  notifiableType: String
  notifiableId: UUID
  screenWidth: Int
  notifiablePageType: String
  notifiablePageId: UUID
  accountId: UUID
  dropdownPage: Int
}

"""All input for the `updateNotificationById` mutation."""
input UpdateNotificationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Notification` being updated.
  """
  notificationPatch: NotificationPatch!
  id: UUID!
}

"""The output of our update `PaymentErrorRecord` mutation."""
type UpdatePaymentErrorRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentErrorRecord` that was updated by this mutation."""
  paymentErrorRecord: PaymentErrorRecord

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PaymentErrorRecord`. May be used by Relay 1."""
  paymentErrorRecordEdge(
    """The method to use when ordering `PaymentErrorRecord`."""
    orderBy: [PaymentErrorRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentErrorRecordsEdge
}

"""All input for the `updatePaymentErrorRecord` mutation."""
input UpdatePaymentErrorRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PaymentErrorRecord` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PaymentErrorRecord` being updated.
  """
  paymentErrorRecordPatch: PaymentErrorRecordPatch!
}

"""
Represents an update to a `PaymentErrorRecord`. Fields that are set will be updated.
"""
input PaymentErrorRecordPatch {
  id: BigInt
  message: String
  createdAt: Datetime
  updatedAt: Datetime
  accountId: UUID
}

"""All input for the `updatePaymentErrorRecordById` mutation."""
input UpdatePaymentErrorRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PaymentErrorRecord` being updated.
  """
  paymentErrorRecordPatch: PaymentErrorRecordPatch!
  id: BigInt!
}

"""The output of our update `PaymentMethod` mutation."""
type UpdatePaymentMethodPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentMethod` that was updated by this mutation."""
  paymentMethod: PaymentMethod

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `PaymentMethod`."""
  accountByAccountId: Account

  """An edge for our `PaymentMethod`. May be used by Relay 1."""
  paymentMethodEdge(
    """The method to use when ordering `PaymentMethod`."""
    orderBy: [PaymentMethodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentMethodsEdge
}

"""All input for the `updatePaymentMethod` mutation."""
input UpdatePaymentMethodInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PaymentMethod` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `PaymentMethod` being updated.
  """
  paymentMethodPatch: PaymentMethodPatch!
}

"""
Represents an update to a `PaymentMethod`. Fields that are set will be updated.
"""
input PaymentMethodPatch {
  accountId: UUID
  stripeId: String
  last4: String
  expMonth: Int
  expYear: Int
  country: String
  createdAt: Datetime
  updatedAt: Datetime
  id: UUID
  brand: String
}

"""All input for the `updatePaymentMethodById` mutation."""
input UpdatePaymentMethodByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `PaymentMethod` being updated.
  """
  paymentMethodPatch: PaymentMethodPatch!
  id: UUID!
}

"""The output of our update `Plan` mutation."""
type UpdatePlanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plan` that was updated by this mutation."""
  plan: Plan

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plan`. May be used by Relay 1."""
  planEdge(
    """The method to use when ordering `Plan`."""
    orderBy: [PlansOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlansEdge
}

"""All input for the `updatePlan` mutation."""
input UpdatePlanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Plan` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Plan` being updated.
  """
  planPatch: PlanPatch!
}

"""Represents an update to a `Plan`. Fields that are set will be updated."""
input PlanPatch {
  name: String
  slug: String
  period: String
  priceCents: Int
  stripeId: String
  trialLength: Int
  createdAt: Datetime
  updatedAt: Datetime
  id: UUID
  perSeatStripeId: String
  seatsIncluded: Int
  perSeatPriceCents: Int
}

"""All input for the `updatePlanById` mutation."""
input UpdatePlanByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Plan` being updated.
  """
  planPatch: PlanPatch!
  id: UUID!
}

"""The output of our update `ProjectUser` mutation."""
type UpdateProjectUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectUser` that was updated by this mutation."""
  projectUser: ProjectUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ProjectUser`."""
  userByUserId: User

  """Reads a single `Project` that is related to this `ProjectUser`."""
  projectByProjectId: Project

  """Reads a single `Account` that is related to this `ProjectUser`."""
  accountByAccountId: Account

  """An edge for our `ProjectUser`. May be used by Relay 1."""
  projectUserEdge(
    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectUsersEdge
}

"""All input for the `updateProjectUser` mutation."""
input UpdateProjectUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `ProjectUser` being updated.
  """
  projectUserPatch: ProjectUserPatch!
}

"""
Represents an update to a `ProjectUser`. Fields that are set will be updated.
"""
input ProjectUserPatch {
  id: UUID
  userId: UUID
  projectId: UUID
  notificationCount: Int
  guest: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  position: Int
  accountId: UUID
  specificWorkspacesOnly: Boolean
  workspaceBarOpen: Boolean
}

"""All input for the `updateProjectUserById` mutation."""
input UpdateProjectUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `ProjectUser` being updated.
  """
  projectUserPatch: ProjectUserPatch!
  id: UUID!
}

"""The output of our update `Project` mutation."""
type UpdateProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was updated by this mutation."""
  project: Project

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Project`."""
  accountByAccountId: Account

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `updateProject` mutation."""
input UpdateProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  projectPatch: ProjectPatch!
}

"""
Represents an update to a `Project`. Fields that are set will be updated.
"""
input ProjectPatch {
  id: UUID
  name: String
  accountId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  archived: Boolean
  globalAccess: Boolean
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
}

"""All input for the `updateProjectById` mutation."""
input UpdateProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Project` being updated.
  """
  projectPatch: ProjectPatch!
  id: UUID!
}

"""The output of our update `Reaction` mutation."""
type UpdateReactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reaction` that was updated by this mutation."""
  reaction: Reaction

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `Reaction`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `Reaction`."""
  userByUserId: User

  """An edge for our `Reaction`. May be used by Relay 1."""
  reactionEdge(
    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReactionsEdge
}

"""All input for the `updateReaction` mutation."""
input UpdateReactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Reaction` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Reaction` being updated.
  """
  reactionPatch: ReactionPatch!
}

"""
Represents an update to a `Reaction`. Fields that are set will be updated.
"""
input ReactionPatch {
  id: UUID
  messageId: UUID
  userId: UUID
  text: String
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateReactionById` mutation."""
input UpdateReactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Reaction` being updated.
  """
  reactionPatch: ReactionPatch!
  id: UUID!
}

"""The output of our update `Recording` mutation."""
type UpdateRecordingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Recording` that was updated by this mutation."""
  recording: Recording

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Recording`."""
  userByUserId: User

  """Reads a single `Version` that is related to this `Recording`."""
  versionByVersionId: Version

  """An edge for our `Recording`. May be used by Relay 1."""
  recordingEdge(
    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecordingsEdge
}

"""All input for the `updateRecording` mutation."""
input UpdateRecordingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Recording` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Recording` being updated.
  """
  recordingPatch: RecordingPatch!
}

"""
Represents an update to a `Recording`. Fields that are set will be updated.
"""
input RecordingPatch {
  createdAt: Datetime
  updatedAt: Datetime
  isIntro: Boolean
  reviewer: String
  slug: String
  userId: UUID
  page: Int
  id: UUID
  versionId: UUID
  thumbnailProcessingStatus: Int
  viewedBy: JSON
  isDemo: Boolean
}

"""All input for the `updateRecordingById` mutation."""
input UpdateRecordingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Recording` being updated.
  """
  recordingPatch: RecordingPatch!
  id: UUID!
}

"""The output of our update `SchemaMigration` mutation."""
type UpdateSchemaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SchemaMigration` that was updated by this mutation."""
  schemaMigration: SchemaMigration

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `SchemaMigration`. May be used by Relay 1."""
  schemaMigrationEdge(
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchemaMigrationsEdge
}

"""All input for the `updateSchemaMigration` mutation."""
input UpdateSchemaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SchemaMigration` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SchemaMigration` being updated.
  """
  schemaMigrationPatch: SchemaMigrationPatch!
}

"""
Represents an update to a `SchemaMigration`. Fields that are set will be updated.
"""
input SchemaMigrationPatch {
  version: String
}

"""All input for the `updateSchemaMigrationByVersion` mutation."""
input UpdateSchemaMigrationByVersionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `SchemaMigration` being updated.
  """
  schemaMigrationPatch: SchemaMigrationPatch!
  version: String!
}

"""The output of our update `Sequence` mutation."""
type UpdateSequencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Sequence` that was updated by this mutation."""
  sequence: Sequence

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Sequence`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Sequence`."""
  userBySenderId: User

  """An edge for our `Sequence`. May be used by Relay 1."""
  sequenceEdge(
    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SequencesEdge
}

"""All input for the `updateSequence` mutation."""
input UpdateSequenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Sequence` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Sequence` being updated.
  """
  sequencePatch: SequencePatch!
}

"""
Represents an update to a `Sequence`. Fields that are set will be updated.
"""
input SequencePatch {
  id: BigInt
  createdAt: Datetime
  updatedAt: Datetime
  frequency: String
  linkClicked: Boolean
  unsubscribed: Boolean
  emailsSent: Int
  lastSentAt: Datetime
  nextJobId: String
  cancelled: Boolean
  userId: UUID
  senderId: UUID
  sequencableType: String
  sequencableId: UUID
  message: String
  subject: String
}

"""All input for the `updateSequenceById` mutation."""
input UpdateSequenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Sequence` being updated.
  """
  sequencePatch: SequencePatch!
  id: BigInt!
}

"""The output of our update `SiteFile` mutation."""
type UpdateSiteFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SiteFile` that was updated by this mutation."""
  siteFile: SiteFile

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Item` that is related to this `SiteFile`."""
  itemByItemId: Item

  """An edge for our `SiteFile`. May be used by Relay 1."""
  siteFileEdge(
    """The method to use when ordering `SiteFile`."""
    orderBy: [SiteFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SiteFilesEdge
}

"""All input for the `updateSiteFile` mutation."""
input UpdateSiteFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SiteFile` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `SiteFile` being updated.
  """
  siteFilePatch: SiteFilePatch!
}

"""
Represents an update to a `SiteFile`. Fields that are set will be updated.
"""
input SiteFilePatch {
  createdAt: Datetime
  updatedAt: Datetime
  filename: String
  itemId: UUID
  id: UUID
}

"""All input for the `updateSiteFileById` mutation."""
input UpdateSiteFileByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `SiteFile` being updated.
  """
  siteFilePatch: SiteFilePatch!
  id: UUID!
}

"""The output of our update `StorageFolder` mutation."""
type UpdateStorageFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StorageFolder` that was updated by this mutation."""
  storageFolder: StorageFolder

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `StorageFolder`."""
  accountByAccountId: Account

  """
  Reads a single `StorageFolder` that is related to this `StorageFolder`.
  """
  storageFolderByParentId: StorageFolder

  """Reads a single `Project` that is related to this `StorageFolder`."""
  projectByProjectId: Project

  """An edge for our `StorageFolder`. May be used by Relay 1."""
  storageFolderEdge(
    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): StorageFoldersEdge
}

"""All input for the `updateStorageFolder` mutation."""
input UpdateStorageFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StorageFolder` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `StorageFolder` being updated.
  """
  storageFolderPatch: StorageFolderPatch!
}

"""
Represents an update to a `StorageFolder`. Fields that are set will be updated.
"""
input StorageFolderPatch {
  id: UUID
  name: String
  accountId: UUID
  parentId: UUID
  projectId: UUID
  createdAt: Datetime
  updatedAt: Datetime
}

"""All input for the `updateStorageFolderById` mutation."""
input UpdateStorageFolderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `StorageFolder` being updated.
  """
  storageFolderPatch: StorageFolderPatch!
  id: UUID!
}

"""The output of our update `Stroke` mutation."""
type UpdateStrokePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Stroke` that was updated by this mutation."""
  stroke: Stroke

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Stroke`."""
  versionByVersionId: Version

  """An edge for our `Stroke`. May be used by Relay 1."""
  strokeEdge(
    """The method to use when ordering `Stroke`."""
    orderBy: [StrokesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StrokesEdge
}

"""All input for the `updateStroke` mutation."""
input UpdateStrokeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Stroke` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Stroke` being updated.
  """
  strokePatch: StrokePatch!
}

"""
Represents an update to a `Stroke`. Fields that are set will be updated.
"""
input StrokePatch {
  id: BigInt
  page: Int
  drawing: String
  createdAt: Datetime
  updatedAt: Datetime
  versionId: UUID
  screenWidth: Int
}

"""All input for the `updateStrokeById` mutation."""
input UpdateStrokeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Stroke` being updated.
  """
  strokePatch: StrokePatch!
  id: BigInt!
}

"""The output of our update `Subscription` mutation."""
type UpdateSubscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Subscription` that was updated by this mutation."""
  subscription: Subscription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Subscription`."""
  accountByAccountId: Account

  """Reads a single `Plan` that is related to this `Subscription`."""
  planByPlanId: Plan

  """An edge for our `Subscription`. May be used by Relay 1."""
  subscriptionEdge(
    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionsEdge
}

"""All input for the `updateSubscription` mutation."""
input UpdateSubscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Subscription` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Subscription` being updated.
  """
  subscriptionPatch: SubscriptionPatch!
}

"""
Represents an update to a `Subscription`. Fields that are set will be updated.
"""
input SubscriptionPatch {
  id: UUID
  accountId: UUID
  planId: UUID
  stripeId: String
  status: Int
  startAt: Datetime
  trialStartAt: Datetime
  renewAt: Datetime
  endAt: Datetime
  cancelledAt: Datetime
  createdAt: Datetime
  updatedAt: Datetime
  items: JSON
}

"""All input for the `updateSubscriptionById` mutation."""
input UpdateSubscriptionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Subscription` being updated.
  """
  subscriptionPatch: SubscriptionPatch!
  id: UUID!
}

"""The output of our update `Suggestion` mutation."""
type UpdateSuggestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Suggestion` that was updated by this mutation."""
  suggestion: Suggestion

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Transcription` that is related to this `Suggestion`."""
  transcriptionByTranscriptionId: Transcription

  """An edge for our `Suggestion`. May be used by Relay 1."""
  suggestionEdge(
    """The method to use when ordering `Suggestion`."""
    orderBy: [SuggestionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuggestionsEdge
}

"""All input for the `updateSuggestion` mutation."""
input UpdateSuggestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Suggestion` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Suggestion` being updated.
  """
  suggestionPatch: SuggestionPatch!
}

"""
Represents an update to a `Suggestion`. Fields that are set will be updated.
"""
input SuggestionPatch {
  id: BigInt
  transcriptionId: BigInt
  content: String
  createdAt: Datetime
  updatedAt: Datetime
  reviewed: Boolean
}

"""All input for the `updateSuggestionById` mutation."""
input UpdateSuggestionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Suggestion` being updated.
  """
  suggestionPatch: SuggestionPatch!
  id: BigInt!
}

"""The output of our update `Todo` mutation."""
type UpdateTodoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Todo` that was updated by this mutation."""
  todo: Todo

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Todo`. May be used by Relay 1."""
  todoEdge(
    """The method to use when ordering `Todo`."""
    orderBy: [TodosOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodosEdge
}

"""All input for the `updateTodo` mutation."""
input UpdateTodoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Todo` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Todo` being updated.
  """
  todoPatch: TodoPatch!
}

"""Represents an update to a `Todo`. Fields that are set will be updated."""
input TodoPatch {
  id: UUID
  text: String
  position: Int
  resolved: Boolean
  createdAt: Datetime
  updatedAt: Datetime
  todoableId: UUID
  todoableType: String
}

"""All input for the `updateTodoById` mutation."""
input UpdateTodoByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Todo` being updated.
  """
  todoPatch: TodoPatch!
  id: UUID!
}

"""The output of our update `Transcription` mutation."""
type UpdateTranscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transcription` that was updated by this mutation."""
  transcription: Transcription

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Recording` that is related to this `Transcription`."""
  recordingByRecordingId: Recording

  """An edge for our `Transcription`. May be used by Relay 1."""
  transcriptionEdge(
    """The method to use when ordering `Transcription`."""
    orderBy: [TranscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TranscriptionsEdge
}

"""All input for the `updateTranscription` mutation."""
input UpdateTranscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transcription` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Transcription` being updated.
  """
  transcriptionPatch: TranscriptionPatch!
}

"""
Represents an update to a `Transcription`. Fields that are set will be updated.
"""
input TranscriptionPatch {
  id: BigInt
  jobName: String
  jobStatus: Int
  createdAt: Datetime
  updatedAt: Datetime
  recordingId: UUID
  content: String
}

"""All input for the `updateTranscriptionById` mutation."""
input UpdateTranscriptionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Transcription` being updated.
  """
  transcriptionPatch: TranscriptionPatch!
  id: BigInt!
}

"""The output of our update `User` mutation."""
type UpdateUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was updated by this mutation."""
  user: User

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `User`."""
  accountByCurrentAccountId: Account

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `updateUser` mutation."""
input UpdateUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  userPatch: UserPatch!
}

"""Represents an update to a `User`. Fields that are set will be updated."""
input UserPatch {
  email: String
  firstName: String
  lastName: String
  id: UUID
  photoProcessingStatus: Int
  photoProcessingError: String
  notificationCount: Int
  currentAccountId: UUID
  showSidebar: Boolean
  emailOnProductUpdates: Boolean
  emailOnMessages: Boolean
  emailOnFeedback: Boolean
  emailLimitToDaily: Boolean
  enableDesktopNotifications: Boolean
  color: String
  emailOnMentionsAndAssignments: Boolean
  hasUsedTrial: Boolean
  currentMic: String
  currentCamera: String
  showTextToolbars: Boolean
  emojiSkinTone: String
  penColor: String
  penSize: Float
  photoTemporary: String
  hasDesktopApp: Boolean
  offerDesktopApp: Boolean
  conversationsOpen: Boolean
  currentRoute: String
}

"""All input for the `updateUserById` mutation."""
input UpdateUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `User` being updated.
  """
  userPatch: UserPatch!
  id: UUID!
}

"""The output of our update `Version` mutation."""
type UpdateVersionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Version` that was updated by this mutation."""
  version: Version

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Document` that is related to this `Version`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `Version`."""
  userByUserId: User

  """An edge for our `Version`. May be used by Relay 1."""
  versionEdge(
    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VersionsEdge
}

"""All input for the `updateVersion` mutation."""
input UpdateVersionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Version` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Version` being updated.
  """
  versionPatch: VersionPatch!
}

"""
Represents an update to a `Version`. Fields that are set will be updated.
"""
input VersionPatch {
  slug: String
  createdAt: Datetime
  updatedAt: Datetime
  count: Int
  dimensions: JSON
  versionNumber: Int
  id: UUID
  documentId: UUID
  thumbnailProcessingStatus: Int
  processingErrorReason: String
  firstFileIsImage: Boolean
  userId: UUID
  figmaLink: String
}

"""All input for the `updateVersionById` mutation."""
input UpdateVersionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Version` being updated.
  """
  versionPatch: VersionPatch!
  id: UUID!
}

"""The output of our update `WorkspaceUser` mutation."""
type UpdateWorkspaceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `WorkspaceUser` that was updated by this mutation."""
  workspaceUser: WorkspaceUser

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `WorkspaceUser`."""
  userByUserId: User

  """Reads a single `Workspace` that is related to this `WorkspaceUser`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Project` that is related to this `WorkspaceUser`."""
  projectByProjectId: Project

  """An edge for our `WorkspaceUser`. May be used by Relay 1."""
  workspaceUserEdge(
    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspaceUsersEdge
}

"""All input for the `updateWorkspaceUser` mutation."""
input UpdateWorkspaceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `WorkspaceUser` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `WorkspaceUser` being updated.
  """
  workspaceUserPatch: WorkspaceUserPatch!
}

"""
Represents an update to a `WorkspaceUser`. Fields that are set will be updated.
"""
input WorkspaceUserPatch {
  userId: UUID
  createdAt: Datetime
  updatedAt: Datetime
  notificationCount: Int
  guest: Boolean
  lastViewed: Datetime
  workspaceId: UUID
  lastReadDiscussionAt: Datetime
  id: UUID
  position: Int
  projectId: UUID
  muted: Boolean
}

"""All input for the `updateWorkspaceUserById` mutation."""
input UpdateWorkspaceUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `WorkspaceUser` being updated.
  """
  workspaceUserPatch: WorkspaceUserPatch!
  id: UUID!
}

"""The output of our update `Workspace` mutation."""
type UpdateWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was updated by this mutation."""
  workspace: Workspace

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjectId: Project

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `updateWorkspace` mutation."""
input UpdateWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Workspace` to be updated.
  """
  nodeId: ID!

  """
  An object where the defined keys will be set on the `Workspace` being updated.
  """
  workspacePatch: WorkspacePatch!
}

"""
Represents an update to a `Workspace`. Fields that are set will be updated.
"""
input WorkspacePatch {
  name: String
  createdAt: Datetime
  updatedAt: Datetime
  slug: String
  figmaDeletedIds: JSON
  category: Int
  id: UUID
  projectId: UUID
  archived: Boolean
  globalAccess: Boolean
  globalAccessToken: String
  globalAccessTokenExpiresAt: Datetime
}

"""All input for the `updateWorkspaceById` mutation."""
input UpdateWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  An object where the defined keys will be set on the `Workspace` being updated.
  """
  workspacePatch: WorkspacePatch!
  id: UUID!
}

"""The output of our delete `AccountUser` mutation."""
type DeleteAccountUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `AccountUser` that was deleted by this mutation."""
  accountUser: AccountUser
  deletedAccountUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `AccountUser`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `AccountUser`."""
  accountByAccountId: Account

  """An edge for our `AccountUser`. May be used by Relay 1."""
  accountUserEdge(
    """The method to use when ordering `AccountUser`."""
    orderBy: [AccountUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountUsersEdge
}

"""All input for the `deleteAccountUser` mutation."""
input DeleteAccountUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `AccountUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAccountUserById` mutation."""
input DeleteAccountUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Account` mutation."""
type DeleteAccountPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Account` that was deleted by this mutation."""
  account: Account
  deletedAccountId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Account`."""
  userByOwnerId: User

  """Reads a single `Subscription` that is related to this `Account`."""
  subscriptionByCurrentSubscriptionId: Subscription

  """Reads a single `PaymentMethod` that is related to this `Account`."""
  paymentMethodByCurrentPaymentMethodId: PaymentMethod

  """An edge for our `Account`. May be used by Relay 1."""
  accountEdge(
    """The method to use when ordering `Account`."""
    orderBy: [AccountsOrderBy!] = [PRIMARY_KEY_ASC]
  ): AccountsEdge
}

"""All input for the `deleteAccount` mutation."""
input DeleteAccountInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Account` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteAccountById` mutation."""
input DeleteAccountByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `ActiveStorageAttachment` mutation."""
type DeleteActiveStorageAttachmentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageAttachment` that was deleted by this mutation."""
  activeStorageAttachment: ActiveStorageAttachment
  deletedActiveStorageAttachmentId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageAttachment`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageAttachment`. May be used by Relay 1."""
  activeStorageAttachmentEdge(
    """The method to use when ordering `ActiveStorageAttachment`."""
    orderBy: [ActiveStorageAttachmentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageAttachmentsEdge
}

"""All input for the `deleteActiveStorageAttachment` mutation."""
input DeleteActiveStorageAttachmentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageAttachment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteActiveStorageAttachmentById` mutation."""
input DeleteActiveStorageAttachmentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ActiveStorageBlob` mutation."""
type DeleteActiveStorageBlobPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageBlob` that was deleted by this mutation."""
  activeStorageBlob: ActiveStorageBlob
  deletedActiveStorageBlobId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ActiveStorageBlob`. May be used by Relay 1."""
  activeStorageBlobEdge(
    """The method to use when ordering `ActiveStorageBlob`."""
    orderBy: [ActiveStorageBlobsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageBlobsEdge
}

"""All input for the `deleteActiveStorageBlob` mutation."""
input DeleteActiveStorageBlobInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageBlob` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteActiveStorageBlobById` mutation."""
input DeleteActiveStorageBlobByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ActiveStorageVariantRecord` mutation."""
type DeleteActiveStorageVariantRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ActiveStorageVariantRecord` that was deleted by this mutation."""
  activeStorageVariantRecord: ActiveStorageVariantRecord
  deletedActiveStorageVariantRecordId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `ActiveStorageBlob` that is related to this `ActiveStorageVariantRecord`.
  """
  activeStorageBlobByBlobId: ActiveStorageBlob

  """An edge for our `ActiveStorageVariantRecord`. May be used by Relay 1."""
  activeStorageVariantRecordEdge(
    """The method to use when ordering `ActiveStorageVariantRecord`."""
    orderBy: [ActiveStorageVariantRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ActiveStorageVariantRecordsEdge
}

"""All input for the `deleteActiveStorageVariantRecord` mutation."""
input DeleteActiveStorageVariantRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ActiveStorageVariantRecord` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteActiveStorageVariantRecordById` mutation."""
input DeleteActiveStorageVariantRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ArInternalMetadatum` mutation."""
type DeleteArInternalMetadatumPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ArInternalMetadatum` that was deleted by this mutation."""
  arInternalMetadatum: ArInternalMetadatum
  deletedArInternalMetadatumId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `ArInternalMetadatum`. May be used by Relay 1."""
  arInternalMetadatumEdge(
    """The method to use when ordering `ArInternalMetadatum`."""
    orderBy: [ArInternalMetadataOrderBy!] = [PRIMARY_KEY_ASC]
  ): ArInternalMetadataEdge
}

"""All input for the `deleteArInternalMetadatum` mutation."""
input DeleteArInternalMetadatumInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ArInternalMetadatum` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteArInternalMetadatumByKey` mutation."""
input DeleteArInternalMetadatumByKeyInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  key: String!
}

"""The output of our delete `CommentThread` mutation."""
type DeleteCommentThreadPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `CommentThread` that was deleted by this mutation."""
  commentThread: CommentThread
  deletedCommentThreadId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `CommentThread`."""
  versionByVersionId: Version

  """An edge for our `CommentThread`. May be used by Relay 1."""
  commentThreadEdge(
    """The method to use when ordering `CommentThread`."""
    orderBy: [CommentThreadsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentThreadsEdge
}

"""All input for the `deleteCommentThread` mutation."""
input DeleteCommentThreadInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `CommentThread` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCommentThreadById` mutation."""
input DeleteCommentThreadByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Comment` mutation."""
type DeleteCommentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Comment` that was deleted by this mutation."""
  comment: Comment
  deletedCommentId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Comment`. May be used by Relay 1."""
  commentEdge(
    """The method to use when ordering `Comment`."""
    orderBy: [CommentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): CommentsEdge
}

"""All input for the `deleteComment` mutation."""
input DeleteCommentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Comment` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteCommentById` mutation."""
input DeleteCommentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `ContactUser` mutation."""
type DeleteContactUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ContactUser` that was deleted by this mutation."""
  contactUser: ContactUser
  deletedContactUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ContactUser`."""
  userByContactId: User

  """Reads a single `User` that is related to this `ContactUser`."""
  userByUserId: User

  """An edge for our `ContactUser`. May be used by Relay 1."""
  contactUserEdge(
    """The method to use when ordering `ContactUser`."""
    orderBy: [ContactUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ContactUsersEdge
}

"""All input for the `deleteContactUser` mutation."""
input DeleteContactUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ContactUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteContactUserById` mutation."""
input DeleteContactUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `ConversationUser` mutation."""
type DeleteConversationUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ConversationUser` that was deleted by this mutation."""
  conversationUser: ConversationUser
  deletedConversationUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """
  Reads a single `Conversation` that is related to this `ConversationUser`.
  """
  conversationByConversationId: Conversation

  """Reads a single `User` that is related to this `ConversationUser`."""
  userByUserId: User

  """An edge for our `ConversationUser`. May be used by Relay 1."""
  conversationUserEdge(
    """The method to use when ordering `ConversationUser`."""
    orderBy: [ConversationUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationUsersEdge
}

"""All input for the `deleteConversationUser` mutation."""
input DeleteConversationUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ConversationUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteConversationUserById` mutation."""
input DeleteConversationUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Conversation` mutation."""
type DeleteConversationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Conversation` that was deleted by this mutation."""
  conversation: Conversation
  deletedConversationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Conversation`."""
  accountByAccountId: Account

  """An edge for our `Conversation`. May be used by Relay 1."""
  conversationEdge(
    """The method to use when ordering `Conversation`."""
    orderBy: [ConversationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ConversationsEdge
}

"""All input for the `deleteConversation` mutation."""
input DeleteConversationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Conversation` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteConversationById` mutation."""
input DeleteConversationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `DocumentUser` mutation."""
type DeleteDocumentUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `DocumentUser` that was deleted by this mutation."""
  documentUser: DocumentUser
  deletedDocumentUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByUserId: User

  """Reads a single `Document` that is related to this `DocumentUser`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `DocumentUser`."""
  userByAssignerId: User

  """An edge for our `DocumentUser`. May be used by Relay 1."""
  documentUserEdge(
    """The method to use when ordering `DocumentUser`."""
    orderBy: [DocumentUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentUsersEdge
}

"""All input for the `deleteDocumentUser` mutation."""
input DeleteDocumentUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `DocumentUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDocumentUserById` mutation."""
input DeleteDocumentUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Document` mutation."""
type DeleteDocumentPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Document` that was deleted by this mutation."""
  document: Document
  deletedDocumentId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Document`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Lane` that is related to this `Document`."""
  laneByLaneId: Lane

  """Reads a single `User` that is related to this `Document`."""
  userByUserId: User

  """Reads a single `Account` that is related to this `Document`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Document`."""
  projectByProjectId: Project

  """Reads a single `StorageFolder` that is related to this `Document`."""
  storageFolderByStorageFolderId: StorageFolder

  """An edge for our `Document`. May be used by Relay 1."""
  documentEdge(
    """The method to use when ordering `Document`."""
    orderBy: [DocumentsOrderBy!] = [PRIMARY_KEY_ASC]
  ): DocumentsEdge
}

"""All input for the `deleteDocument` mutation."""
input DeleteDocumentInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Document` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteDocumentById` mutation."""
input DeleteDocumentByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Email` mutation."""
type DeleteEmailPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Email` that was deleted by this mutation."""
  email: Email
  deletedEmailId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Email`."""
  versionByVersionId: Version

  """Reads a single `Document` that is related to this `Email`."""
  documentByDocumentId: Document

  """Reads a single `Workspace` that is related to this `Email`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Email`."""
  accountByAccountId: Account

  """Reads a single `Project` that is related to this `Email`."""
  projectByProjectId: Project

  """Reads a single `Conversation` that is related to this `Email`."""
  conversationByConversationId: Conversation

  """An edge for our `Email`. May be used by Relay 1."""
  emailEdge(
    """The method to use when ordering `Email`."""
    orderBy: [EmailsOrderBy!] = [PRIMARY_KEY_ASC]
  ): EmailsEdge
}

"""All input for the `deleteEmail` mutation."""
input DeleteEmailInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Email` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteEmailById` mutation."""
input DeleteEmailByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `FigmaPage` mutation."""
type DeleteFigmaPagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `FigmaPage` that was deleted by this mutation."""
  figmaPage: FigmaPage
  deletedFigmaPageId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `FigmaPage`. May be used by Relay 1."""
  figmaPageEdge(
    """The method to use when ordering `FigmaPage`."""
    orderBy: [FigmaPagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): FigmaPagesEdge
}

"""All input for the `deleteFigmaPage` mutation."""
input DeleteFigmaPageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `FigmaPage` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteFigmaPageById` mutation."""
input DeleteFigmaPageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Invoice` mutation."""
type DeleteInvoicePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Invoice` that was deleted by this mutation."""
  invoice: Invoice
  deletedInvoiceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Invoice`."""
  accountByAccountId: Account

  """Reads a single `Subscription` that is related to this `Invoice`."""
  subscriptionBySubscriptionId: Subscription

  """An edge for our `Invoice`. May be used by Relay 1."""
  invoiceEdge(
    """The method to use when ordering `Invoice`."""
    orderBy: [InvoicesOrderBy!] = [PRIMARY_KEY_ASC]
  ): InvoicesEdge
}

"""All input for the `deleteInvoice` mutation."""
input DeleteInvoiceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Invoice` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteInvoiceById` mutation."""
input DeleteInvoiceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Item` mutation."""
type DeleteItemPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Item` that was deleted by this mutation."""
  item: Item
  deletedItemId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Item`."""
  versionByVersionId: Version

  """An edge for our `Item`. May be used by Relay 1."""
  itemEdge(
    """The method to use when ordering `Item`."""
    orderBy: [ItemsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ItemsEdge
}

"""All input for the `deleteItem` mutation."""
input DeleteItemInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Item` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteItemById` mutation."""
input DeleteItemByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Lane` mutation."""
type DeleteLanePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Lane` that was deleted by this mutation."""
  lane: Lane
  deletedLaneId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Workspace` that is related to this `Lane`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Account` that is related to this `Lane`."""
  accountByAccountId: Account

  """An edge for our `Lane`. May be used by Relay 1."""
  laneEdge(
    """The method to use when ordering `Lane`."""
    orderBy: [LanesOrderBy!] = [PRIMARY_KEY_ASC]
  ): LanesEdge
}

"""All input for the `deleteLane` mutation."""
input DeleteLaneInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Lane` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteLaneById` mutation."""
input DeleteLaneByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Mention` mutation."""
type DeleteMentionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Mention` that was deleted by this mutation."""
  mention: Mention
  deletedMentionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Mention`."""
  userByUserId: User

  """An edge for our `Mention`. May be used by Relay 1."""
  mentionEdge(
    """The method to use when ordering `Mention`."""
    orderBy: [MentionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): MentionsEdge
}

"""All input for the `deleteMention` mutation."""
input DeleteMentionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Mention` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMentionById` mutation."""
input DeleteMentionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `MessageFile` mutation."""
type DeleteMessageFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageFile` that was deleted by this mutation."""
  messageFile: MessageFile
  deletedMessageFileId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageFile`."""
  messageByMessageId: Message

  """An edge for our `MessageFile`. May be used by Relay 1."""
  messageFileEdge(
    """The method to use when ordering `MessageFile`."""
    orderBy: [MessageFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageFilesEdge
}

"""All input for the `deleteMessageFile` mutation."""
input DeleteMessageFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MessageFile` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMessageFileById` mutation."""
input DeleteMessageFileByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `MessageUser` mutation."""
type DeleteMessageUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `MessageUser` that was deleted by this mutation."""
  messageUser: MessageUser
  deletedMessageUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `MessageUser`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `MessageUser`."""
  userByUserId: User

  """An edge for our `MessageUser`. May be used by Relay 1."""
  messageUserEdge(
    """The method to use when ordering `MessageUser`."""
    orderBy: [MessageUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessageUsersEdge
}

"""All input for the `deleteMessageUser` mutation."""
input DeleteMessageUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `MessageUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMessageUserById` mutation."""
input DeleteMessageUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Message` mutation."""
type DeleteMessagePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Message` that was deleted by this mutation."""
  message: Message
  deletedMessageId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Message`."""
  userByUserId: User

  """An edge for our `Message`. May be used by Relay 1."""
  messageEdge(
    """The method to use when ordering `Message`."""
    orderBy: [MessagesOrderBy!] = [PRIMARY_KEY_ASC]
  ): MessagesEdge
}

"""All input for the `deleteMessage` mutation."""
input DeleteMessageInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Message` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteMessageById` mutation."""
input DeleteMessageByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Notification` mutation."""
type DeleteNotificationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Notification` that was deleted by this mutation."""
  notification: Notification
  deletedNotificationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Notification`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Notification`."""
  userByOriginatorId: User

  """Reads a single `Version` that is related to this `Notification`."""
  versionByVersionId: Version

  """Reads a single `Account` that is related to this `Notification`."""
  accountByAccountId: Account

  """An edge for our `Notification`. May be used by Relay 1."""
  notificationEdge(
    """The method to use when ordering `Notification`."""
    orderBy: [NotificationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): NotificationsEdge
}

"""All input for the `deleteNotification` mutation."""
input DeleteNotificationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Notification` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteNotificationById` mutation."""
input DeleteNotificationByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `PaymentErrorRecord` mutation."""
type DeletePaymentErrorRecordPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentErrorRecord` that was deleted by this mutation."""
  paymentErrorRecord: PaymentErrorRecord
  deletedPaymentErrorRecordId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `PaymentErrorRecord`. May be used by Relay 1."""
  paymentErrorRecordEdge(
    """The method to use when ordering `PaymentErrorRecord`."""
    orderBy: [PaymentErrorRecordsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentErrorRecordsEdge
}

"""All input for the `deletePaymentErrorRecord` mutation."""
input DeletePaymentErrorRecordInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PaymentErrorRecord` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePaymentErrorRecordById` mutation."""
input DeletePaymentErrorRecordByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `PaymentMethod` mutation."""
type DeletePaymentMethodPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `PaymentMethod` that was deleted by this mutation."""
  paymentMethod: PaymentMethod
  deletedPaymentMethodId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `PaymentMethod`."""
  accountByAccountId: Account

  """An edge for our `PaymentMethod`. May be used by Relay 1."""
  paymentMethodEdge(
    """The method to use when ordering `PaymentMethod`."""
    orderBy: [PaymentMethodsOrderBy!] = [PRIMARY_KEY_ASC]
  ): PaymentMethodsEdge
}

"""All input for the `deletePaymentMethod` mutation."""
input DeletePaymentMethodInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `PaymentMethod` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePaymentMethodById` mutation."""
input DeletePaymentMethodByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Plan` mutation."""
type DeletePlanPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Plan` that was deleted by this mutation."""
  plan: Plan
  deletedPlanId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Plan`. May be used by Relay 1."""
  planEdge(
    """The method to use when ordering `Plan`."""
    orderBy: [PlansOrderBy!] = [PRIMARY_KEY_ASC]
  ): PlansEdge
}

"""All input for the `deletePlan` mutation."""
input DeletePlanInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Plan` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deletePlanById` mutation."""
input DeletePlanByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `ProjectUser` mutation."""
type DeleteProjectUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `ProjectUser` that was deleted by this mutation."""
  projectUser: ProjectUser
  deletedProjectUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `ProjectUser`."""
  userByUserId: User

  """Reads a single `Project` that is related to this `ProjectUser`."""
  projectByProjectId: Project

  """Reads a single `Account` that is related to this `ProjectUser`."""
  accountByAccountId: Account

  """An edge for our `ProjectUser`. May be used by Relay 1."""
  projectUserEdge(
    """The method to use when ordering `ProjectUser`."""
    orderBy: [ProjectUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectUsersEdge
}

"""All input for the `deleteProjectUser` mutation."""
input DeleteProjectUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `ProjectUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProjectUserById` mutation."""
input DeleteProjectUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Project` mutation."""
type DeleteProjectPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Project` that was deleted by this mutation."""
  project: Project
  deletedProjectId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Project`."""
  accountByAccountId: Account

  """An edge for our `Project`. May be used by Relay 1."""
  projectEdge(
    """The method to use when ordering `Project`."""
    orderBy: [ProjectsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ProjectsEdge
}

"""All input for the `deleteProject` mutation."""
input DeleteProjectInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Project` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteProjectById` mutation."""
input DeleteProjectByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Reaction` mutation."""
type DeleteReactionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Reaction` that was deleted by this mutation."""
  reaction: Reaction
  deletedReactionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Message` that is related to this `Reaction`."""
  messageByMessageId: Message

  """Reads a single `User` that is related to this `Reaction`."""
  userByUserId: User

  """An edge for our `Reaction`. May be used by Relay 1."""
  reactionEdge(
    """The method to use when ordering `Reaction`."""
    orderBy: [ReactionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): ReactionsEdge
}

"""All input for the `deleteReaction` mutation."""
input DeleteReactionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Reaction` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteReactionById` mutation."""
input DeleteReactionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Recording` mutation."""
type DeleteRecordingPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Recording` that was deleted by this mutation."""
  recording: Recording
  deletedRecordingId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Recording`."""
  userByUserId: User

  """Reads a single `Version` that is related to this `Recording`."""
  versionByVersionId: Version

  """An edge for our `Recording`. May be used by Relay 1."""
  recordingEdge(
    """The method to use when ordering `Recording`."""
    orderBy: [RecordingsOrderBy!] = [PRIMARY_KEY_ASC]
  ): RecordingsEdge
}

"""All input for the `deleteRecording` mutation."""
input DeleteRecordingInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Recording` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteRecordingById` mutation."""
input DeleteRecordingByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `SchemaMigration` mutation."""
type DeleteSchemaMigrationPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SchemaMigration` that was deleted by this mutation."""
  schemaMigration: SchemaMigration
  deletedSchemaMigrationId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `SchemaMigration`. May be used by Relay 1."""
  schemaMigrationEdge(
    """The method to use when ordering `SchemaMigration`."""
    orderBy: [SchemaMigrationsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SchemaMigrationsEdge
}

"""All input for the `deleteSchemaMigration` mutation."""
input DeleteSchemaMigrationInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SchemaMigration` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSchemaMigrationByVersion` mutation."""
input DeleteSchemaMigrationByVersionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  version: String!
}

"""The output of our delete `Sequence` mutation."""
type DeleteSequencePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Sequence` that was deleted by this mutation."""
  sequence: Sequence
  deletedSequenceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `Sequence`."""
  userByUserId: User

  """Reads a single `User` that is related to this `Sequence`."""
  userBySenderId: User

  """An edge for our `Sequence`. May be used by Relay 1."""
  sequenceEdge(
    """The method to use when ordering `Sequence`."""
    orderBy: [SequencesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SequencesEdge
}

"""All input for the `deleteSequence` mutation."""
input DeleteSequenceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Sequence` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSequenceById` mutation."""
input DeleteSequenceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `SiteFile` mutation."""
type DeleteSiteFilePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `SiteFile` that was deleted by this mutation."""
  siteFile: SiteFile
  deletedSiteFileId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Item` that is related to this `SiteFile`."""
  itemByItemId: Item

  """An edge for our `SiteFile`. May be used by Relay 1."""
  siteFileEdge(
    """The method to use when ordering `SiteFile`."""
    orderBy: [SiteFilesOrderBy!] = [PRIMARY_KEY_ASC]
  ): SiteFilesEdge
}

"""All input for the `deleteSiteFile` mutation."""
input DeleteSiteFileInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `SiteFile` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSiteFileById` mutation."""
input DeleteSiteFileByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `StorageFolder` mutation."""
type DeleteStorageFolderPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `StorageFolder` that was deleted by this mutation."""
  storageFolder: StorageFolder
  deletedStorageFolderId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `StorageFolder`."""
  accountByAccountId: Account

  """
  Reads a single `StorageFolder` that is related to this `StorageFolder`.
  """
  storageFolderByParentId: StorageFolder

  """Reads a single `Project` that is related to this `StorageFolder`."""
  projectByProjectId: Project

  """An edge for our `StorageFolder`. May be used by Relay 1."""
  storageFolderEdge(
    """The method to use when ordering `StorageFolder`."""
    orderBy: [StorageFoldersOrderBy!] = [PRIMARY_KEY_ASC]
  ): StorageFoldersEdge
}

"""All input for the `deleteStorageFolder` mutation."""
input DeleteStorageFolderInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `StorageFolder` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStorageFolderById` mutation."""
input DeleteStorageFolderByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Stroke` mutation."""
type DeleteStrokePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Stroke` that was deleted by this mutation."""
  stroke: Stroke
  deletedStrokeId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Version` that is related to this `Stroke`."""
  versionByVersionId: Version

  """An edge for our `Stroke`. May be used by Relay 1."""
  strokeEdge(
    """The method to use when ordering `Stroke`."""
    orderBy: [StrokesOrderBy!] = [PRIMARY_KEY_ASC]
  ): StrokesEdge
}

"""All input for the `deleteStroke` mutation."""
input DeleteStrokeInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Stroke` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteStrokeById` mutation."""
input DeleteStrokeByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Subscription` mutation."""
type DeleteSubscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Subscription` that was deleted by this mutation."""
  subscription: Subscription
  deletedSubscriptionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `Subscription`."""
  accountByAccountId: Account

  """Reads a single `Plan` that is related to this `Subscription`."""
  planByPlanId: Plan

  """An edge for our `Subscription`. May be used by Relay 1."""
  subscriptionEdge(
    """The method to use when ordering `Subscription`."""
    orderBy: [SubscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SubscriptionsEdge
}

"""All input for the `deleteSubscription` mutation."""
input DeleteSubscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Subscription` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSubscriptionById` mutation."""
input DeleteSubscriptionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Suggestion` mutation."""
type DeleteSuggestionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Suggestion` that was deleted by this mutation."""
  suggestion: Suggestion
  deletedSuggestionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Transcription` that is related to this `Suggestion`."""
  transcriptionByTranscriptionId: Transcription

  """An edge for our `Suggestion`. May be used by Relay 1."""
  suggestionEdge(
    """The method to use when ordering `Suggestion`."""
    orderBy: [SuggestionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): SuggestionsEdge
}

"""All input for the `deleteSuggestion` mutation."""
input DeleteSuggestionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Suggestion` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteSuggestionById` mutation."""
input DeleteSuggestionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `Todo` mutation."""
type DeleteTodoPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Todo` that was deleted by this mutation."""
  todo: Todo
  deletedTodoId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """An edge for our `Todo`. May be used by Relay 1."""
  todoEdge(
    """The method to use when ordering `Todo`."""
    orderBy: [TodosOrderBy!] = [PRIMARY_KEY_ASC]
  ): TodosEdge
}

"""All input for the `deleteTodo` mutation."""
input DeleteTodoInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Todo` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTodoById` mutation."""
input DeleteTodoByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Transcription` mutation."""
type DeleteTranscriptionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Transcription` that was deleted by this mutation."""
  transcription: Transcription
  deletedTranscriptionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Recording` that is related to this `Transcription`."""
  recordingByRecordingId: Recording

  """An edge for our `Transcription`. May be used by Relay 1."""
  transcriptionEdge(
    """The method to use when ordering `Transcription`."""
    orderBy: [TranscriptionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): TranscriptionsEdge
}

"""All input for the `deleteTranscription` mutation."""
input DeleteTranscriptionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Transcription` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteTranscriptionById` mutation."""
input DeleteTranscriptionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: BigInt!
}

"""The output of our delete `User` mutation."""
type DeleteUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `User` that was deleted by this mutation."""
  user: User
  deletedUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Account` that is related to this `User`."""
  accountByCurrentAccountId: Account

  """An edge for our `User`. May be used by Relay 1."""
  userEdge(
    """The method to use when ordering `User`."""
    orderBy: [UsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): UsersEdge
}

"""All input for the `deleteUser` mutation."""
input DeleteUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `User` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteUserById` mutation."""
input DeleteUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Version` mutation."""
type DeleteVersionPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Version` that was deleted by this mutation."""
  version: Version
  deletedVersionId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Document` that is related to this `Version`."""
  documentByDocumentId: Document

  """Reads a single `User` that is related to this `Version`."""
  userByUserId: User

  """An edge for our `Version`. May be used by Relay 1."""
  versionEdge(
    """The method to use when ordering `Version`."""
    orderBy: [VersionsOrderBy!] = [PRIMARY_KEY_ASC]
  ): VersionsEdge
}

"""All input for the `deleteVersion` mutation."""
input DeleteVersionInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Version` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteVersionById` mutation."""
input DeleteVersionByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `WorkspaceUser` mutation."""
type DeleteWorkspaceUserPayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `WorkspaceUser` that was deleted by this mutation."""
  workspaceUser: WorkspaceUser
  deletedWorkspaceUserId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `User` that is related to this `WorkspaceUser`."""
  userByUserId: User

  """Reads a single `Workspace` that is related to this `WorkspaceUser`."""
  workspaceByWorkspaceId: Workspace

  """Reads a single `Project` that is related to this `WorkspaceUser`."""
  projectByProjectId: Project

  """An edge for our `WorkspaceUser`. May be used by Relay 1."""
  workspaceUserEdge(
    """The method to use when ordering `WorkspaceUser`."""
    orderBy: [WorkspaceUsersOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspaceUsersEdge
}

"""All input for the `deleteWorkspaceUser` mutation."""
input DeleteWorkspaceUserInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `WorkspaceUser` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWorkspaceUserById` mutation."""
input DeleteWorkspaceUserByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}

"""The output of our delete `Workspace` mutation."""
type DeleteWorkspacePayload {
  """
  The exact same `clientMutationId` that was provided in the mutation input,
  unchanged and unused. May be used by a client to track mutations.
  """
  clientMutationId: String

  """The `Workspace` that was deleted by this mutation."""
  workspace: Workspace
  deletedWorkspaceId: ID

  """
  Our root query field type. Allows us to run any query from our mutation payload.
  """
  query: Query

  """Reads a single `Project` that is related to this `Workspace`."""
  projectByProjectId: Project

  """An edge for our `Workspace`. May be used by Relay 1."""
  workspaceEdge(
    """The method to use when ordering `Workspace`."""
    orderBy: [WorkspacesOrderBy!] = [PRIMARY_KEY_ASC]
  ): WorkspacesEdge
}

"""All input for the `deleteWorkspace` mutation."""
input DeleteWorkspaceInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String

  """
  The globally unique `ID` which will identify a single `Workspace` to be deleted.
  """
  nodeId: ID!
}

"""All input for the `deleteWorkspaceById` mutation."""
input DeleteWorkspaceByIdInput {
  """
  An arbitrary string value with no semantic meaning. Will be included in the
  payload verbatim. May be used to track mutations by the client.
  """
  clientMutationId: String
  id: UUID!
}
